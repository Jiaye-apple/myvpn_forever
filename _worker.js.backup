
import { connect } from 'cloudflare:sockets';

let userID = '';
let proxyIP = '';
let DNS64Server = '';
//let sub = '';
let subConverter = atob('U1VCQVBJLkNNTGl1c3Nzcy5uZXQ=');
let subConfig = atob('aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0FDTDRTU1IvQUNMNFNTUi9tYXN0ZXIvQ2xhc2gvY29uZmlnL0FDTDRTU1JfT25saW5lX01pbmlfTXVsdGlNb2RlLmluaQ==');
let subProtocol = 'https';
let subEmoji = 'true';
let socks5Address = '';
let parsedSocks5Address = {};
let enableSocks = false;
let enableHttp = false;
let noTLS = 'false';
const expire = 4102329600;//2099-12-31
let proxyIPs;
let socks5s;
let go2Socks5s = [
    '*ttvnw.net',
    '*tapecontent.net',
    '*cloudatacdn.com',
    '*.loadshare.org',
];
let addresses = [];
let addressesapi = [];
let addressesnotls = [];
let addressesnotlsapi = [];
let addressescsv = [];
let DLS = 8;
let remarkIndex = 1;//CSVå¤‡æ³¨æ‰€åœ¨åˆ—åç§»é‡
let FileName = atob('ZWRnZXR1bm5lbA==');
let BotToken;
let ChatID;
let proxyhosts = [];
let proxyhostsURL = atob('aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NtbGl1L2NtbGl1L21haW4vUHJveHlIT1NU');
let RproxyIP = 'false';
const httpPorts = ["8080", "8880", "2052", "2082", "2086", "2095"];
let httpsPorts = ["2053", "2083", "2087", "2096", "8443"];
let æœ‰æ•ˆæ—¶é—´ = 7;
let æ›´æ–°æ—¶é—´ = 3;
let userIDLow;
let userIDTime = "";
let proxyIPPool = [];
let path = '/?ed=2560';
let åŠ¨æ€UUID = userID;
let link = [];
let banHosts = [atob('c3BlZWQuY2xvdWRmbGFyZS5jb20=')];
let SCV = 'true';
let allowInsecure = '&allowInsecure=1';
export default {
    async fetch(request, env, ctx) {
        try {
            const UA = request.headers.get('User-Agent') || 'null';
            const userAgent = UA.toLowerCase();
            userID = env.UUID || env.uuid || env.PASSWORD || env.pswd || userID;
            if (env.KEY || env.TOKEN || (userID && !isValidUUID(userID))) {
                åŠ¨æ€UUID = env.KEY || env.TOKEN || userID;
                æœ‰æ•ˆæ—¶é—´ = Number(env.TIME) || æœ‰æ•ˆæ—¶é—´;
                æ›´æ–°æ—¶é—´ = Number(env.UPTIME) || æ›´æ–°æ—¶é—´;
                const userIDs = await ç”ŸæˆåŠ¨æ€UUID(åŠ¨æ€UUID);
                userID = userIDs[0];
                userIDLow = userIDs[1];
            } else åŠ¨æ€UUID = userID;

            if (!userID) {
                return new Response('è¯·è®¾ç½®ä½ çš„UUIDå˜é‡ï¼Œæˆ–å°è¯•é‡è¯•éƒ¨ç½²ï¼Œæ£€æŸ¥å˜é‡æ˜¯å¦ç”Ÿæ•ˆï¼Ÿ', {
                    status: 404,
                    headers: {
                        "Content-Type": "text/plain;charset=utf-8",
                    }
                });
            }
            const currentDate = new Date();
            currentDate.setHours(0, 0, 0, 0);
            const timestamp = Math.ceil(currentDate.getTime() / 1000);
            const fakeUserIDMD5 = await åŒé‡å“ˆå¸Œ(`${userID}${timestamp}`);
            const fakeUserID = [
                fakeUserIDMD5.slice(0, 8),
                fakeUserIDMD5.slice(8, 12),
                fakeUserIDMD5.slice(12, 16),
                fakeUserIDMD5.slice(16, 20),
                fakeUserIDMD5.slice(20)
            ].join('-');

            const fakeHostName = `${fakeUserIDMD5.slice(6, 9)}.${fakeUserIDMD5.slice(13, 19)}`;

            proxyIP = env.PROXYIP || env.proxyip || proxyIP;
            proxyIPs = await æ•´ç†(proxyIP);
            proxyIP = proxyIPs[Math.floor(Math.random() * proxyIPs.length)];
            DNS64Server = env.DNS64 || env.NAT64 || DNS64Server;
            socks5Address = env.HTTP || env.SOCKS5 || socks5Address;
            socks5s = await æ•´ç†(socks5Address);
            socks5Address = socks5s[Math.floor(Math.random() * socks5s.length)];
            enableHttp = env.HTTP ? true : socks5Address.toLowerCase().includes('http://');
            socks5Address = socks5Address.split('//')[1] || socks5Address;
            if (env.GO2SOCKS5) go2Socks5s = await æ•´ç†(env.GO2SOCKS5);
            if (env.CFPORTS) httpsPorts = await æ•´ç†(env.CFPORTS);
            if (env.BAN) banHosts = await æ•´ç†(env.BAN);
            if (socks5Address) {
                try {
                    parsedSocks5Address = socks5AddressParser(socks5Address);
                    RproxyIP = env.RPROXYIP || 'false';
                    enableSocks = true;
                } catch (err) {
                    let e = err;
                    console.log(e.toString());
                    RproxyIP = env.RPROXYIP || !proxyIP ? 'true' : 'false';
                    enableSocks = false;
                }
            } else {
                RproxyIP = env.RPROXYIP || !proxyIP ? 'true' : 'false';
            }

            const upgradeHeader = request.headers.get('Upgrade');
            const url = new URL(request.url);
            if (!upgradeHeader || upgradeHeader !== 'websocket') {
                if (env.ADD) addresses = await æ•´ç†(env.ADD);
                if (env.ADDAPI) addressesapi = await æ•´ç†(env.ADDAPI);
                if (env.ADDNOTLS) addressesnotls = await æ•´ç†(env.ADDNOTLS);
                if (env.ADDNOTLSAPI) addressesnotlsapi = await æ•´ç†(env.ADDNOTLSAPI);
                if (env.ADDCSV) addressescsv = await æ•´ç†(env.ADDCSV);
                DLS = Number(env.DLS) || DLS;
                remarkIndex = Number(env.CSVREMARK) || remarkIndex;
                BotToken = env.TGTOKEN || BotToken;
                ChatID = env.TGID || ChatID;
                FileName = env.SUBNAME || FileName;
                subEmoji = env.SUBEMOJI || env.EMOJI || subEmoji;
                if (subEmoji == '0') subEmoji = 'false';
                if (env.LINK) link = await æ•´ç†(env.LINK);
                let sub = env.SUB || '';
                subConverter = env.SUBAPI || subConverter;
                if (subConverter.includes("http://")) {
                    subConverter = subConverter.split("//")[1];
                    subProtocol = 'http';
                } else {
                    subConverter = subConverter.split("//")[1] || subConverter;
                }
                subConfig = env.SUBCONFIG || subConfig;
                if (url.searchParams.has('sub') && url.searchParams.get('sub') !== '') sub = url.searchParams.get('sub').toLowerCase();
                if (url.searchParams.has('notls')) noTLS = 'true';

                if (url.searchParams.has('proxyip')) {
                    path = `/proxyip=${url.searchParams.get('proxyip')}`;
                    RproxyIP = 'false';
                } else if (url.searchParams.has('socks5')) {
                    path = `/?socks5=${url.searchParams.get('socks5')}`;
                    RproxyIP = 'false';
                } else if (url.searchParams.has('socks')) {
                    path = `/?socks5=${url.searchParams.get('socks')}`;
                    RproxyIP = 'false';
                }

                SCV = env.SCV || SCV;
                if (!SCV || SCV == '0' || SCV == 'false') allowInsecure = '';
                else SCV = 'true';
                const è·¯å¾„ = url.pathname.toLowerCase();
                if (è·¯å¾„ == '/') {
                    if (env.URL302) return Response.redirect(env.URL302, 302);
                    else if (env.URL) return await ä»£ç†URL(env.URL, url);
                    else return new Response(`
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ—å®¶ä¸š - ä¸ªäººç®€ä»‹</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
            color: #ffffff;
            overflow-x: hidden;
            min-height: 100vh;
        }

        /* åŠ¨æ€èƒŒæ™¯ç²’å­æ•ˆæœ */
        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: rgba(64, 224, 255, 0.8);
            border-radius: 50%;
            animation: float 8s infinite linear;
        }

        @keyframes float {
            0% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { transform: translateY(-100px) rotate(360deg); opacity: 0; }
        }

        .container {
            position: relative;
            z-index: 10;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        /* å¤´éƒ¨åŒºåŸŸ */
        .hero-section {
            text-align: center;
            padding: 80px 0 60px;
            position: relative;
        }

        .name-title {
            font-size: 4.5rem;
            font-weight: 700;
            background: linear-gradient(45deg, #40e0ff, #4169e1, #9370db);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradient-shift 3s ease-in-out infinite;
            margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(64, 224, 255, 0.5);
        }

        @keyframes gradient-shift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .subtitle {
            font-size: 1.4rem;
            color: #40e0ff;
            margin-bottom: 40px;
            font-weight: 300;
            letter-spacing: 2px;
        }

        /* ä¸»è¦å†…å®¹åŒºåŸŸ */
        .content-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 60px;
            padding: 40px 0;
            align-items: start;
        }

        .info-card {
            background: rgba(26, 26, 46, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(64, 224, 255, 0.2);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.3),
                0 0 0 1px rgba(64, 224, 255, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .info-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(64, 224, 255, 0.1), transparent);
            transition: left 0.5s;
        }

        .info-card:hover::before {
            left: 100%;
        }

        .info-card:hover {
            transform: translateY(-5px);
            box-shadow: 
                0 30px 60px rgba(0, 0, 0, 0.4),
                0 0 0 1px rgba(64, 224, 255, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .card-title {
            font-size: 1.8rem;
            color: #40e0ff;
            margin-bottom: 25px;
            font-weight: 600;
            position: relative;
        }

        .card-title::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 0;
            width: 60px;
            height: 3px;
            background: linear-gradient(45deg, #40e0ff, #4169e1);
            border-radius: 2px;
        }

        .info-item {
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            font-size: 1.1rem;
            line-height: 1.6;
        }

        .info-item::before {
            content: 'â–¸';
            color: #40e0ff;
            font-size: 1.2rem;
            margin-right: 12px;
            font-weight: bold;
        }

        /* ç‰¹æ®Šå¼ºè°ƒæ ·å¼ */
        .highlight {
            background: linear-gradient(45deg, #40e0ff, #4169e1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 600;
        }

        /* æˆå°±å±•ç¤ºåŒºåŸŸ */
        .achievements {
            grid-column: 1 / -1;
            margin-top: 40px;
        }

        .achievements-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 30px;
            margin-top: 30px;
        }

        .achievement-item {
            background: rgba(16, 33, 62, 0.6);
            border: 1px solid rgba(64, 224, 255, 0.15);
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .achievement-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(45deg, #40e0ff, #4169e1, #9370db);
            background-size: 300% 300%;
            animation: gradient-shift 3s ease-in-out infinite;
        }

        .achievement-item:hover {
            transform: translateY(-8px);
            border-color: rgba(64, 224, 255, 0.4);
            box-shadow: 0 15px 30px rgba(64, 224, 255, 0.2);
        }

        .achievement-icon {
            font-size: 2.5rem;
            margin-bottom: 15px;
            display: block;
        }

        .achievement-title {
            font-size: 1.3rem;
            color: #40e0ff;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .achievement-desc {
            font-size: 0.95rem;
            color: #b8c5d6;
            line-height: 1.5;
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            .name-title {
                font-size: 3rem;
            }
            
            .content-section {
                grid-template-columns: 1fr;
                gap: 30px;
            }
            
            .info-card {
                padding: 30px;
            }
            
            .achievements-grid {
                grid-template-columns: 1fr;
            }
        }

        /* æ»šåŠ¨åŠ¨ç”» */
        .fade-in {
            opacity: 0;
            transform: translateY(30px);
            transition: all 0.8s ease;
        }

        .fade-in.visible {
            opacity: 1;
            transform: translateY(0);
        }
    </style>
</head>
<body>
    <!-- åŠ¨æ€èƒŒæ™¯ç²’å­ -->
    <div class="particles" id="particles"></div>

    <div class="container">
        <!-- å¤´éƒ¨åŒºåŸŸ -->
        <div class="hero-section fade-in">
            <h1 class="name-title">æ—å®¶ä¸š</h1>
            <p class="subtitle">æ˜Ÿç«é»‘ç§‘æŠ€ç ”ç©¶é™¢åˆ›å§‹äºº Â· CEO å…¼é™¢é•¿</p>
        </div>

        <!-- ä¸»è¦å†…å®¹åŒºåŸŸ -->
        <div class="content-section">
            <!-- åŸºæœ¬ä¿¡æ¯ -->
            <div class="info-card fade-in">
                <h2 class="card-title">åŸºæœ¬ä¿¡æ¯</h2>
                <div class="info-item">
                    <span class="highlight">åå—å¸ˆèŒƒå¤§å­¦</span> å­¦è€…
                </div>
                <div class="info-item">
                    <span class="highlight">ä¸­å›½æ•™è‚²å­¦ä¼š</span> ä¼šå‘˜
                </div>
                <div class="info-item">
                    <span class="highlight">ä¸­å›½è®¡ç®—æœºå­¦ä¼š</span> ä¼šå‘˜
                </div>
                <div class="info-item">
                    ç¡¬ç¬”ä¹¦æ³• <span class="highlight">ä¸ƒçº§</span> è®¤è¯
                </div>
            </div>

            <!-- èŒä¸šæˆå°± -->
            <div class="info-card fade-in">
                <h2 class="card-title">èŒä¸šæˆå°±</h2>
                <div class="info-item">
                    <span class="highlight">æ˜Ÿç«é»‘ç§‘æŠ€ç ”ç©¶é™¢</span> åˆ›å§‹äºº
                </div>
                <div class="info-item">
                    ç ”ç©¶é™¢ <span class="highlight">CEO å…¼é™¢é•¿</span>
                </div>
                <div class="info-item">
                    å¤šä¸ª <span class="highlight">å›½å®¶çº§æƒå¨æœŸåˆŠ</span> å‘è¡¨æ–‡ç« 
                </div>
                <div class="info-item">
                    è·å¾— <span class="highlight">å¤šé¡¹ä¸“ä¸šå¥–é¡¹</span>
                </div>
            </div>
        </div>

        <!-- æˆå°±å±•ç¤ºåŒºåŸŸ -->
        <div class="achievements fade-in">
            <h2 class="card-title" style="text-align: center; font-size: 2.2rem;">ä¸“ä¸šé¢†åŸŸ</h2>
            <div class="achievements-grid">
                <div class="achievement-item fade-in">
                    <span class="achievement-icon">ğŸ“</span>
                    <h3 class="achievement-title">æ•™è‚²ç ”ç©¶</h3>
                    <p class="achievement-desc">åå—å¸ˆèŒƒå¤§å­¦å­¦æœ¯èƒŒæ™¯ï¼Œä¸­å›½æ•™è‚²å­¦ä¼šä¼šå‘˜ï¼Œä¸“æ³¨æ•™è‚²åˆ›æ–°ç ”ç©¶</p>
                </div>
                <div class="achievement-item fade-in">
                    <span class="achievement-icon">ğŸ’»</span>
                    <h3 class="achievement-title">è®¡ç®—æœºç§‘å­¦</h3>
                    <p class="achievement-desc">ä¸­å›½è®¡ç®—æœºå­¦ä¼šä¼šå‘˜ï¼Œåœ¨å‰æ²¿æŠ€æœ¯é¢†åŸŸå…·æœ‰æ·±åšé€ è¯£</p>
                </div>
                <div class="achievement-item fade-in">
                    <span class="achievement-icon">ğŸš€</span>
                    <h3 class="achievement-title">ç§‘æŠ€åˆ›æ–°</h3>
                    <p class="achievement-desc">æ˜Ÿç«é»‘ç§‘æŠ€ç ”ç©¶é™¢åˆ›å§‹äººï¼Œå¼•é¢†æœªæ¥ç§‘æŠ€å‘å±•æ–¹å‘</p>
                </div>
                <div class="achievement-item fade-in">
                    <span class="achievement-icon">âœï¸</span>
                    <h3 class="achievement-title">ä¹¦æ³•è‰ºæœ¯</h3>
                    <p class="achievement-desc">ç¡¬ç¬”ä¹¦æ³•ä¸ƒçº§è®¤è¯ï¼Œå°†ä¼ ç»Ÿæ–‡åŒ–ä¸ç°ä»£ç§‘æŠ€å®Œç¾ç»“åˆ</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // æŠ—æ··æ·†ç‰ˆæœ¬ - ä½¿ç”¨æ›´ç›´æ¥çš„DOMæ“ä½œ
        (function() {
            // åˆ›å»ºç²’å­æ•ˆæœ - ä½¿ç”¨ç«‹å³æ‰§è¡Œå‡½æ•°é¿å…å…¨å±€å˜é‡å†²çª
            function init() {
                var p = document['getElementById']('particles');
                if (!p) return;
                
                for (var i = 0; i < 50; i++) {
                    var d = document['createElement']('div');
                    d['className'] = 'particle';
                    d['style']['left'] = Math['random']() * 100 + '%';
                    d['style']['animationDelay'] = Math['random']() * 8 + 's';
                    d['style']['animationDuration'] = (Math['random']() * 3 + 5) + 's';
                    p['appendChild'](d);
                }
            }

            // æ»šåŠ¨åŠ¨ç”»å¤„ç†
            function scroll() {
                var els = document['querySelectorAll']('.fade-in');
                var h = window['innerHeight'];
                
                for (var i = 0; i < els['length']; i++) {
                    var el = els[i];
                    var top = el['getBoundingClientRect']()['top'];
                    if (top < h - 150) {
                        el['classList']['add']('visible');
                    }
                }
            }

            // å»¶è¿Ÿæ˜¾ç¤ºåŠ¨ç”»
            function show() {
                var hero = document['querySelector']('.hero-section');
                if (hero) hero['classList']['add']('visible');
                
                setTimeout(function() {
                    var cards = document['querySelectorAll']('.info-card');
                    for (var i = 0; i < cards['length']; i++) {
                        (function(idx, card) {
                            setTimeout(function() {
                                card['classList']['add']('visible');
                            }, idx * 200);
                        })(i, cards[i]);
                    }
                }, 500);
                
                setTimeout(function() {
                    var achieve = document['querySelector']('.achievements');
                    if (achieve) achieve['classList']['add']('visible');
                    
                    var items = document['querySelectorAll']('.achievement-item');
                    for (var i = 0; i < items['length']; i++) {
                        (function(idx, item) {
                            setTimeout(function() {
                                item['classList']['add']('visible');
                            }, idx * 150);
                        })(i, items[i]);
                    }
                }, 1000);
            }

            // äº‹ä»¶ç»‘å®š
            if (document['readyState'] === 'loading') {
                document['addEventListener']('DOMContentLoaded', function() {
                    init();
                    scroll();
                    show();
                });
            } else {
                init();
                scroll();
                show();
            }
            
            window['addEventListener']('scroll', scroll);
        })();
    </script>
</body>
</html>
`, {
                        status: 200,
                        headers: {
                            'Content-Type': 'text/html; charset=UTF-8',
                        },
                    });
                } else if (è·¯å¾„ == `/${fakeUserID}`) {
                    const fakeConfig = await ç”Ÿæˆé…ç½®ä¿¡æ¯(userID, request.headers.get('Host'), sub, 'CF-Workers-SUB', RproxyIP, url, fakeUserID, fakeHostName, env);
                    return new Response(`${fakeConfig}`, { status: 200 });
                } else if (url.pathname == `/${åŠ¨æ€UUID}/edit` || è·¯å¾„ == `/${userID}/edit`) {
                    return await KV(request, env);
                } else if (url.pathname == `/${åŠ¨æ€UUID}/bestip` || è·¯å¾„ == `/${userID}/bestip`) {
                    return await bestIP(request, env);
                } else if (url.pathname == `/${åŠ¨æ€UUID}` || è·¯å¾„ == `/${userID}`) {
                    await sendMessage(`#è·å–è®¢é˜… ${FileName}`, request.headers.get('CF-Connecting-IP'), `UA: ${UA}</tg-spoiler>\nåŸŸå: ${url.hostname}\n<tg-spoiler>å…¥å£: ${url.pathname + url.search}</tg-spoiler>`);
                    const ç»´åˆ—æ–¯Config = await ç”Ÿæˆé…ç½®ä¿¡æ¯(userID, request.headers.get('Host'), sub, UA, RproxyIP, url, fakeUserID, fakeHostName, env);
                    const now = Date.now();
                    //const timestamp = Math.floor(now / 1000);
                    const today = new Date(now);
                    today.setHours(0, 0, 0, 0);
                    const UD = Math.floor(((now - today.getTime()) / 86400000) * 24 * 1099511627776 / 2);
                    let pagesSum = UD;
                    let workersSum = UD;
                    let total = 24 * 1099511627776;
                    if ((env.CF_EMAIL && env.CF_APIKEY) || (env.CF_ID && env.CF_APITOKEN)) {
                        const usage = await getUsage(env.CF_ID, env.CF_EMAIL, env.CF_APIKEY, env.CF_APITOKEN, env.CF_ALL);
                        pagesSum = usage[1];
                        workersSum = usage[2];
                        total = env.CF_ALL ? Number(env.CF_ALL) : (1024 * 100); // 100K
                    }
                    if (userAgent && userAgent.includes('mozilla')) {
                        return new Response(ç»´åˆ—æ–¯Config, {
                            status: 200,
                            headers: {
                                "Content-Type": "text/html;charset=utf-8",
                                "Profile-Update-Interval": "6",
                                "Subscription-Userinfo": `upload=${pagesSum}; download=${workersSum}; total=${total}; expire=${expire}`,
                                "Cache-Control": "no-store",
                            }
                        });
                    } else {
                        return new Response(ç»´åˆ—æ–¯Config, {
                            status: 200,
                            headers: {
                                "Content-Disposition": `attachment; filename=${FileName}; filename*=utf-8''${encodeURIComponent(FileName)}`,
                                //"Content-Type": "text/plain;charset=utf-8",
                                "Profile-Update-Interval": "6",
                                "Profile-web-page-url": request.url.includes('?') ? request.url.split('?')[0] : request.url,
                                "Subscription-Userinfo": `upload=${pagesSum}; download=${workersSum}; total=${total}; expire=${expire}`,
                            }
                        });
                    }
                } else {
                    if (env.URL302) return Response.redirect(env.URL302, 302);
                    else if (env.URL) return await ä»£ç†URL(env.URL, url);
                    else return new Response('ä¸ç”¨æ€€ç–‘ï¼ä½ UUIDå°±æ˜¯é”™çš„ï¼ï¼ï¼', { status: 404 });
                }
            } else {
                socks5Address = url.searchParams.get('socks5') || socks5Address;
                if (new RegExp('/socks5=', 'i').test(url.pathname)) socks5Address = url.pathname.split('5=')[1];
                else if (new RegExp('/socks://', 'i').test(url.pathname) || new RegExp('/socks5://', 'i').test(url.pathname) || new RegExp('/http://', 'i').test(url.pathname)) {
                    enableHttp = url.pathname.includes('http://');
                    socks5Address = url.pathname.split('://')[1].split('#')[0];
                    if (socks5Address.includes('@')) {
                        const lastAtIndex = socks5Address.lastIndexOf('@');
                        let userPassword = socks5Address.substring(0, lastAtIndex).replaceAll('%3D', '=');
                        const base64Regex = /^(?:[A-Z0-9+/]{4})*(?:[A-Z0-9+/]{2}==|[A-Z0-9+/]{3}=)?$/i;
                        if (base64Regex.test(userPassword) && !userPassword.includes(':')) userPassword = atob(userPassword);
                        socks5Address = `${userPassword}@${socks5Address.substring(lastAtIndex + 1)}`;
                    }
                    go2Socks5s = ['all in'];//å¼€å¯å…¨å±€SOCKS5
                }

                if (socks5Address) {
                    try {
                        parsedSocks5Address = socks5AddressParser(socks5Address);
                        enableSocks = true;
                    } catch (err) {
                        let e = err;
                        console.log(e.toString());
                        enableSocks = false;
                    }
                } else {
                    enableSocks = false;
                }

                if (url.searchParams.has('proxyip')) {
                    proxyIP = url.searchParams.get('proxyip');
                    enableSocks = false;
                } else if (new RegExp('/proxyip=', 'i').test(url.pathname)) {
                    proxyIP = url.pathname.toLowerCase().split('/proxyip=')[1];
                    enableSocks = false;
                } else if (new RegExp('/proxyip.', 'i').test(url.pathname)) {
                    proxyIP = `proxyip.${url.pathname.toLowerCase().split("/proxyip.")[1]}`;
                    enableSocks = false;
                } else if (new RegExp('/pyip=', 'i').test(url.pathname)) {
                    proxyIP = url.pathname.toLowerCase().split('/pyip=')[1];
                    enableSocks = false;
                }

                return await ç»´åˆ—æ–¯OverWSHandler(request);
            }
        } catch (err) {
            let e = err;
            return new Response(e.toString());
        }
    },
};

async function ç»´åˆ—æ–¯OverWSHandler(request) {

    // @ts-ignore
    const webSocketPair = new WebSocketPair();
    const [client, webSocket] = Object.values(webSocketPair);

    // æ¥å— WebSocket è¿æ¥
    webSocket.accept();

    let address = '';
    let portWithRandomLog = '';
    // æ—¥å¿—å‡½æ•°ï¼Œç”¨äºè®°å½•è¿æ¥ä¿¡æ¯
    const log = (/** @type {string} */ info, /** @type {string | undefined} */ event) => {
        console.log(`[${address}:${portWithRandomLog}] ${info}`, event || '');
    };
    // è·å–æ—©æœŸæ•°æ®å¤´éƒ¨ï¼Œå¯èƒ½åŒ…å«äº†ä¸€äº›åˆå§‹åŒ–æ•°æ®
    const earlyDataHeader = request.headers.get('sec-websocket-protocol') || '';

    // åˆ›å»ºä¸€ä¸ªå¯è¯»çš„ WebSocket æµï¼Œç”¨äºæ¥æ”¶å®¢æˆ·ç«¯æ•°æ®
    const readableWebSocketStream = makeReadableWebSocketStream(webSocket, earlyDataHeader, log);

    // ç”¨äºå­˜å‚¨è¿œç¨‹ Socket çš„åŒ…è£…å™¨
    let remoteSocketWapper = {
        value: null,
    };
    // æ ‡è®°æ˜¯å¦ä¸º DNS æŸ¥è¯¢
    let udpStreamWrite = null;
    let isDns = false;

    // WebSocket æ•°æ®æµå‘è¿œç¨‹æœåŠ¡å™¨çš„ç®¡é“
    readableWebSocketStream.pipeTo(new WritableStream({
        async write(chunk, controller) {
            if (isDns && udpStreamWrite) {
                // å¦‚æœæ˜¯ DNS æŸ¥è¯¢ï¼Œè°ƒç”¨ DNS å¤„ç†å‡½æ•°
                //return await handleDNSQuery(chunk, webSocket, null, log);
                return udpStreamWrite(chunk);
            }
            if (remoteSocketWapper.value) {
                // å¦‚æœå·²æœ‰è¿œç¨‹ Socketï¼Œç›´æ¥å†™å…¥æ•°æ®
                const writer = remoteSocketWapper.value.writable.getWriter()
                await writer.write(chunk);
                writer.releaseLock();
                return;
            }

            // å¤„ç† ç»´åˆ—æ–¯ åè®®å¤´éƒ¨
            const {
                hasError,
                message,
                addressType,
                portRemote = 443,
                addressRemote = '',
                rawDataIndex,
                ç»´åˆ—æ–¯Version = new Uint8Array([0, 0]),
                isUDP,
            } = processç»´åˆ—æ–¯Header(chunk, userID);
            // è®¾ç½®åœ°å€å’Œç«¯å£ä¿¡æ¯ï¼Œç”¨äºæ—¥å¿—
            address = addressRemote;
            portWithRandomLog = `${portRemote}--${Math.random()} ${isUDP ? 'udp ' : 'tcp '} `;
            if (hasError) {
                // å¦‚æœæœ‰é”™è¯¯ï¼ŒæŠ›å‡ºå¼‚å¸¸
                throw new Error(message);
                return;
            }
            // å¦‚æœæ˜¯ UDP ä¸”ç«¯å£ä¸æ˜¯ DNS ç«¯å£ï¼ˆ53ï¼‰ï¼Œåˆ™å…³é—­è¿æ¥
            if (isUDP) {
                if (portRemote === 53) {
                    isDns = true;
                } else {
                    throw new Error('UDP ä»£ç†ä»…å¯¹ DNSï¼ˆ53 ç«¯å£ï¼‰å¯ç”¨');
                    return;
                }
            }
            // æ„å»º ç»´åˆ—æ–¯ å“åº”å¤´éƒ¨
            const ç»´åˆ—æ–¯ResponseHeader = new Uint8Array([ç»´åˆ—æ–¯Version[0], 0]);
            // è·å–å®é™…çš„å®¢æˆ·ç«¯æ•°æ®
            const rawClientData = chunk.slice(rawDataIndex);

            if (isDns) {
                // å¦‚æœæ˜¯ DNS æŸ¥è¯¢ï¼Œè°ƒç”¨ DNS å¤„ç†å‡½æ•°
                //return handleDNSQuery(rawClientData, webSocket, ç»´åˆ—æ–¯ResponseHeader, log);
                const { write } = await handleUDPOutBound(webSocket, ç»´åˆ—æ–¯ResponseHeader, log);
                udpStreamWrite = write;
                udpStreamWrite(rawClientData);
                return;
            }
            // å¤„ç† TCP å‡ºç«™è¿æ¥
            if (!banHosts.includes(addressRemote)) {
                log(`å¤„ç† TCP å‡ºç«™è¿æ¥ ${addressRemote}:${portRemote}`);
                handleTCPOutBound(remoteSocketWapper, addressType, addressRemote, portRemote, rawClientData, webSocket, ç»´åˆ—æ–¯ResponseHeader, log);
            } else {
                throw new Error(`é»‘åå•å…³é—­ TCP å‡ºç«™è¿æ¥ ${addressRemote}:${portRemote}`);
            }
        },
        close() {
            log(`readableWebSocketStream å·²å…³é—­`);
        },
        abort(reason) {
            log(`readableWebSocketStream å·²ä¸­æ­¢`, JSON.stringify(reason));
        },
    })).catch((err) => {
        log('readableWebSocketStream ç®¡é“é”™è¯¯', err);
    });

    // è¿”å›ä¸€ä¸ª WebSocket å‡çº§çš„å“åº”
    return new Response(null, {
        status: 101,
        // @ts-ignore
        webSocket: client,
    });
}

async function handleTCPOutBound(remoteSocket, addressType, addressRemote, portRemote, rawClientData, webSocket, ç»´åˆ—æ–¯ResponseHeader, log,) {
    async function useSocks5Pattern(address) {
        if (go2Socks5s.includes(atob('YWxsIGlu')) || go2Socks5s.includes(atob('Kg=='))) return true;
        return go2Socks5s.some(pattern => {
            let regexPattern = pattern.replace(/\*/g, '.*');
            let regex = new RegExp(`^${regexPattern}$`, 'i');
            return regex.test(address);
        });
    }

    async function connectAndWrite(address, port, socks = false, http = false) {
        log(`connected to ${address}:${port}`);
        //if (/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(address)) address = `${atob('d3d3Lg==')}${address}${atob('LmlwLjA5MDIyNy54eXo=')}`;
        // å…ˆç¡®å®šè¿æ¥æ–¹å¼ï¼Œå†åˆ›å»ºè¿æ¥
        const tcpSocket = socks
            ? (http ? await httpConnect(address, port, log) : await socks5Connect(addressType, address, port, log))
            : connect({ hostname: address, port: port });

        remoteSocket.value = tcpSocket;
        //log(`connected to ${address}:${port}`);
        const writer = tcpSocket.writable.getWriter();
        // é¦–æ¬¡å†™å…¥ï¼Œé€šå¸¸æ˜¯ TLS å®¢æˆ·ç«¯ Hello æ¶ˆæ¯
        await writer.write(rawClientData);
        writer.releaseLock();
        return tcpSocket;
    }

    async function nat64() {
        if (!useSocks) {
            const nat64Proxyip = `[${await resolveToIPv6(addressRemote)}]`;
            log(`NAT64 ä»£ç†è¿æ¥åˆ° ${nat64Proxyip}:443`);
            tcpSocket = await connectAndWrite(nat64Proxyip, 443);
        }
        tcpSocket.closed.catch(error => {
            console.log('retry tcpSocket closed error', error);
        }).finally(() => {
            safeCloseWebSocket(webSocket);
        })
        remoteSocketToWS(tcpSocket, webSocket, ç»´åˆ—æ–¯ResponseHeader, null, log);
    }

    /**
     * é‡è¯•å‡½æ•°ï¼šå½“ Cloudflare çš„ TCP Socket æ²¡æœ‰ä¼ å…¥æ•°æ®æ—¶ï¼Œæˆ‘ä»¬å°è¯•é‡å®šå‘ IP
     * è¿™å¯èƒ½æ˜¯å› ä¸ºæŸäº›ç½‘ç»œé—®é¢˜å¯¼è‡´çš„è¿æ¥å¤±è´¥
     */
    async function retry() {
        if (enableSocks) {
            // å¦‚æœå¯ç”¨äº† SOCKS5ï¼Œé€šè¿‡ SOCKS5 ä»£ç†é‡è¯•è¿æ¥
            tcpSocket = await connectAndWrite(addressRemote, portRemote, true, enableHttp);
        } else {
            // å¦åˆ™ï¼Œå°è¯•ä½¿ç”¨é¢„è®¾çš„ä»£ç† IPï¼ˆå¦‚æœæœ‰ï¼‰æˆ–åŸå§‹åœ°å€é‡è¯•è¿æ¥
            if (!proxyIP || proxyIP == '') {
                proxyIP = atob('UFJPWFlJUC50cDEuMDkwMjI3Lnh5eg==');
            } else if (proxyIP.includes(']:')) {
                portRemote = proxyIP.split(']:')[1] || portRemote;
                proxyIP = proxyIP.split(']:')[0] + "]" || proxyIP;
            } else if (proxyIP.split(':').length === 2) {
                portRemote = proxyIP.split(':')[1] || portRemote;
                proxyIP = proxyIP.split(':')[0] || proxyIP;
            }
            if (proxyIP.includes('.tp')) portRemote = proxyIP.split('.tp')[1].split('.')[0] || portRemote;
            tcpSocket = await connectAndWrite(proxyIP.toLowerCase() || addressRemote, portRemote);
        }
        /* æ— è®ºé‡è¯•æ˜¯å¦æˆåŠŸï¼Œéƒ½è¦å…³é—­ WebSocketï¼ˆå¯èƒ½æ˜¯ä¸ºäº†é‡æ–°å»ºç«‹è¿æ¥ï¼‰
        tcpSocket.closed.catch(error => {
            console.log('retry tcpSocket closed error', error);
        }).finally(() => {
            safeCloseWebSocket(webSocket);
        })
        */
        // å»ºç«‹ä»è¿œç¨‹ Socket åˆ° WebSocket çš„æ•°æ®æµ
        remoteSocketToWS(tcpSocket, webSocket, ç»´åˆ—æ–¯ResponseHeader, nat64, log);
    }

    let useSocks = false;
    if (go2Socks5s.length > 0 && enableSocks) useSocks = await useSocks5Pattern(addressRemote);
    // é¦–æ¬¡å°è¯•è¿æ¥è¿œç¨‹æœåŠ¡å™¨
    let tcpSocket = await connectAndWrite(addressRemote, portRemote, useSocks, enableHttp);

    // å½“è¿œç¨‹ Socket å°±ç»ªæ—¶ï¼Œå°†å…¶ä¼ é€’ç»™ WebSocket
    // å»ºç«‹ä»è¿œç¨‹æœåŠ¡å™¨åˆ° WebSocket çš„æ•°æ®æµï¼Œç”¨äºå°†è¿œç¨‹æœåŠ¡å™¨çš„å“åº”å‘é€å›å®¢æˆ·ç«¯
    // å¦‚æœè¿æ¥å¤±è´¥æˆ–æ— æ•°æ®ï¼Œretry å‡½æ•°å°†è¢«è°ƒç”¨è¿›è¡Œé‡è¯•
    remoteSocketToWS(tcpSocket, webSocket, ç»´åˆ—æ–¯ResponseHeader, retry, log);
}

function makeReadableWebSocketStream(webSocketServer, earlyDataHeader, log) {
    // æ ‡è®°å¯è¯»æµæ˜¯å¦å·²è¢«å–æ¶ˆ
    let readableStreamCancel = false;

    // åˆ›å»ºä¸€ä¸ªæ–°çš„å¯è¯»æµ
    const stream = new ReadableStream({
        // å½“æµå¼€å§‹æ—¶çš„åˆå§‹åŒ–å‡½æ•°
        start(controller) {
            // ç›‘å¬ WebSocket çš„æ¶ˆæ¯äº‹ä»¶
            webSocketServer.addEventListener('message', (event) => {
                // å¦‚æœæµå·²è¢«å–æ¶ˆï¼Œä¸å†å¤„ç†æ–°æ¶ˆæ¯
                if (readableStreamCancel) {
                    return;
                }
                const message = event.data;
                // å°†æ¶ˆæ¯åŠ å…¥æµçš„é˜Ÿåˆ—ä¸­
                controller.enqueue(message);
            });

            // ç›‘å¬ WebSocket çš„å…³é—­äº‹ä»¶
            // æ³¨æ„ï¼šè¿™ä¸ªäº‹ä»¶æ„å‘³ç€å®¢æˆ·ç«¯å…³é—­äº†å®¢æˆ·ç«¯ -> æœåŠ¡å™¨çš„æµ
            // ä½†æ˜¯ï¼ŒæœåŠ¡å™¨ -> å®¢æˆ·ç«¯çš„æµä»ç„¶æ‰“å¼€ï¼Œç›´åˆ°åœ¨æœåŠ¡å™¨ç«¯è°ƒç”¨ close()
            // WebSocket åè®®è¦æ±‚åœ¨æ¯ä¸ªæ–¹å‘ä¸Šéƒ½è¦å‘é€å•ç‹¬çš„å…³é—­æ¶ˆæ¯ï¼Œä»¥å®Œå…¨å…³é—­ Socket
            webSocketServer.addEventListener('close', () => {
                // å®¢æˆ·ç«¯å‘é€äº†å…³é—­ä¿¡å·ï¼Œéœ€è¦å…³é—­æœåŠ¡å™¨ç«¯
                safeCloseWebSocket(webSocketServer);
                // å¦‚æœæµæœªè¢«å–æ¶ˆï¼Œåˆ™å…³é—­æ§åˆ¶å™¨
                if (readableStreamCancel) {
                    return;
                }
                controller.close();
            });

            // ç›‘å¬ WebSocket çš„é”™è¯¯äº‹ä»¶
            webSocketServer.addEventListener('error', (err) => {
                log('WebSocket æœåŠ¡å™¨å‘ç”Ÿé”™è¯¯');
                // å°†é”™è¯¯ä¼ é€’ç»™æ§åˆ¶å™¨
                controller.error(err);
            });

            // å¤„ç† WebSocket 0-RTTï¼ˆé›¶å¾€è¿”æ—¶é—´ï¼‰çš„æ—©æœŸæ•°æ®
            // 0-RTT å…è®¸åœ¨å®Œå…¨å»ºç«‹è¿æ¥ä¹‹å‰å‘é€æ•°æ®ï¼Œæé«˜äº†æ•ˆç‡
            const { earlyData, error } = base64ToArrayBuffer(earlyDataHeader);
            if (error) {
                // å¦‚æœè§£ç æ—©æœŸæ•°æ®æ—¶å‡ºé”™ï¼Œå°†é”™è¯¯ä¼ é€’ç»™æ§åˆ¶å™¨
                controller.error(error);
            } else if (earlyData) {
                // å¦‚æœæœ‰æ—©æœŸæ•°æ®ï¼Œå°†å…¶åŠ å…¥æµçš„é˜Ÿåˆ—ä¸­
                controller.enqueue(earlyData);
            }
        },

        // å½“ä½¿ç”¨è€…ä»æµä¸­æ‹‰å–æ•°æ®æ—¶è°ƒç”¨
        pull(controller) {
            // è¿™é‡Œå¯ä»¥å®ç°åå‹æœºåˆ¶
            // å¦‚æœ WebSocket å¯ä»¥åœ¨æµæ»¡æ—¶åœæ­¢è¯»å–ï¼Œæˆ‘ä»¬å°±å¯ä»¥å®ç°åå‹
            // å‚è€ƒï¼šhttps://streams.spec.whatwg.org/#example-rs-push-backpressure
        },

        // å½“æµè¢«å–æ¶ˆæ—¶è°ƒç”¨
        cancel(reason) {
            // æµè¢«å–æ¶ˆçš„å‡ ç§æƒ…å†µï¼š
            // 1. å½“ç®¡é“çš„ WritableStream æœ‰é”™è¯¯æ—¶ï¼Œè¿™ä¸ªå–æ¶ˆå‡½æ•°ä¼šè¢«è°ƒç”¨ï¼Œæ‰€ä»¥åœ¨è¿™é‡Œå¤„ç† WebSocket æœåŠ¡å™¨çš„å…³é—­
            // 2. å¦‚æœ ReadableStream è¢«å–æ¶ˆï¼Œæ‰€æœ‰ controller.close/enqueue éƒ½éœ€è¦è·³è¿‡
            // 3. ä½†æ˜¯ç»è¿‡æµ‹è¯•ï¼Œå³ä½¿ ReadableStream è¢«å–æ¶ˆï¼Œcontroller.error ä»ç„¶æœ‰æ•ˆ
            if (readableStreamCancel) {
                return;
            }
            log(`å¯è¯»æµè¢«å–æ¶ˆï¼ŒåŸå› æ˜¯ ${reason}`);
            readableStreamCancel = true;
            // å®‰å…¨åœ°å…³é—­ WebSocket
            safeCloseWebSocket(webSocketServer);
        }
    });

    return stream;
}

// https://xtls.github.io/development/protocols/ç»´åˆ—æ–¯.html
// https://github.com/zizifn/excalidraw-backup/blob/main/v2ray-protocol.excalidraw

/**
 * è§£æ ç»´åˆ—æ–¯ åè®®çš„å¤´éƒ¨æ•°æ®
 * @param { ArrayBuffer} ç»´åˆ—æ–¯Buffer ç»´åˆ—æ–¯ åè®®çš„åŸå§‹å¤´éƒ¨æ•°æ®
 * @param {string} userID ç”¨äºéªŒè¯çš„ç”¨æˆ· ID
 * @returns {Object} è§£æç»“æœï¼ŒåŒ…æ‹¬æ˜¯å¦æœ‰é”™è¯¯ã€é”™è¯¯ä¿¡æ¯ã€è¿œç¨‹åœ°å€ä¿¡æ¯ç­‰
 */
function processç»´åˆ—æ–¯Header(ç»´åˆ—æ–¯Buffer, userID) {
    // æ£€æŸ¥æ•°æ®é•¿åº¦æ˜¯å¦è¶³å¤Ÿï¼ˆè‡³å°‘éœ€è¦ 24 å­—èŠ‚ï¼‰
    if (ç»´åˆ—æ–¯Buffer.byteLength < 24) {
        return {
            hasError: true,
            message: 'invalid data',
        };
    }

    // è§£æ ç»´åˆ—æ–¯ åè®®ç‰ˆæœ¬ï¼ˆç¬¬ä¸€ä¸ªå­—èŠ‚ï¼‰
    const version = new Uint8Array(ç»´åˆ—æ–¯Buffer.slice(0, 1));

    let isValidUser = false;
    let isUDP = false;

    // éªŒè¯ç”¨æˆ· IDï¼ˆæ¥ä¸‹æ¥çš„ 16 ä¸ªå­—èŠ‚ï¼‰
    function isUserIDValid(userID, userIDLow, buffer) {
        const userIDArray = new Uint8Array(buffer.slice(1, 17));
        const userIDString = stringify(userIDArray);
        return userIDString === userID || userIDString === userIDLow;
    }

    // ä½¿ç”¨å‡½æ•°éªŒè¯
    isValidUser = isUserIDValid(userID, userIDLow, ç»´åˆ—æ–¯Buffer);

    // å¦‚æœç”¨æˆ· ID æ— æ•ˆï¼Œè¿”å›é”™è¯¯
    if (!isValidUser) {
        return {
            hasError: true,
            message: `invalid user ${(new Uint8Array(ç»´åˆ—æ–¯Buffer.slice(1, 17)))}`,
        };
    }

    // è·å–é™„åŠ é€‰é¡¹çš„é•¿åº¦ï¼ˆç¬¬ 17 ä¸ªå­—èŠ‚ï¼‰
    const optLength = new Uint8Array(ç»´åˆ—æ–¯Buffer.slice(17, 18))[0];
    // æš‚æ—¶è·³è¿‡é™„åŠ é€‰é¡¹

    // è§£æå‘½ä»¤ï¼ˆç´§è·Ÿåœ¨é€‰é¡¹ä¹‹åçš„ 1 ä¸ªå­—èŠ‚ï¼‰
    // 0x01: TCP, 0x02: UDP, 0x03: MUXï¼ˆå¤šè·¯å¤ç”¨ï¼‰
    const command = new Uint8Array(
        ç»´åˆ—æ–¯Buffer.slice(18 + optLength, 18 + optLength + 1)
    )[0];

    // 0x01 TCP
    // 0x02 UDP
    // 0x03 MUX
    if (command === 1) {
        // TCP å‘½ä»¤ï¼Œä¸éœ€ç‰¹æ®Šå¤„ç†
    } else if (command === 2) {
        // UDP å‘½ä»¤
        isUDP = true;
    } else {
        // ä¸æ”¯æŒçš„å‘½ä»¤
        return {
            hasError: true,
            message: `command ${command} is not support, command 01-tcp,02-udp,03-mux`,
        };
    }

    // è§£æè¿œç¨‹ç«¯å£ï¼ˆå¤§ç«¯åºï¼Œ2 å­—èŠ‚ï¼‰
    const portIndex = 18 + optLength + 1;
    const portBuffer = ç»´åˆ—æ–¯Buffer.slice(portIndex, portIndex + 2);
    // port is big-Endian in raw data etc 80 == 0x005d
    const portRemote = new DataView(portBuffer).getUint16(0);

    // è§£æåœ°å€ç±»å‹å’Œåœ°å€
    let addressIndex = portIndex + 2;
    const addressBuffer = new Uint8Array(
        ç»´åˆ—æ–¯Buffer.slice(addressIndex, addressIndex + 1)
    );

    // åœ°å€ç±»å‹ï¼š1-IPv4(4å­—èŠ‚), 2-åŸŸå(å¯å˜é•¿), 3-IPv6(16å­—èŠ‚)
    const addressType = addressBuffer[0];
    let addressLength = 0;
    let addressValueIndex = addressIndex + 1;
    let addressValue = '';

    switch (addressType) {
        case 1:
            // IPv4 åœ°å€
            addressLength = 4;
            // å°† 4 ä¸ªå­—èŠ‚è½¬ä¸ºç‚¹åˆ†åè¿›åˆ¶æ ¼å¼
            addressValue = new Uint8Array(
                ç»´åˆ—æ–¯Buffer.slice(addressValueIndex, addressValueIndex + addressLength)
            ).join('.');
            break;
        case 2:
            // åŸŸå
            // ç¬¬ä¸€ä¸ªå­—èŠ‚æ˜¯åŸŸåé•¿åº¦
            addressLength = new Uint8Array(
                ç»´åˆ—æ–¯Buffer.slice(addressValueIndex, addressValueIndex + 1)
            )[0];
            addressValueIndex += 1;
            // è§£ç åŸŸå
            addressValue = new TextDecoder().decode(
                ç»´åˆ—æ–¯Buffer.slice(addressValueIndex, addressValueIndex + addressLength)
            );
            break;
        case 3:
            // IPv6 åœ°å€
            addressLength = 16;
            const dataView = new DataView(
                ç»´åˆ—æ–¯Buffer.slice(addressValueIndex, addressValueIndex + addressLength)
            );
            // æ¯ 2 å­—èŠ‚æ„æˆ IPv6 åœ°å€çš„ä¸€éƒ¨åˆ†
            const ipv6 = [];
            for (let i = 0; i < 8; i++) {
                ipv6.push(dataView.getUint16(i * 2).toString(16));
            }
            addressValue = ipv6.join(':');
            // seems no need add [] for ipv6
            break;
        default:
            // æ— æ•ˆçš„åœ°å€ç±»å‹
            return {
                hasError: true,
                message: `invild addressType is ${addressType}`,
            };
    }

    // ç¡®ä¿åœ°å€ä¸ä¸ºç©º
    if (!addressValue) {
        return {
            hasError: true,
            message: `addressValue is empty, addressType is ${addressType}`,
        };
    }

    // è¿”å›è§£æç»“æœ
    return {
        hasError: false,
        addressRemote: addressValue,  // è§£æåçš„è¿œç¨‹åœ°å€
        addressType,				 // åœ°å€ç±»å‹
        portRemote,				 // è¿œç¨‹ç«¯å£
        rawDataIndex: addressValueIndex + addressLength,  // åŸå§‹æ•°æ®çš„å®é™…èµ·å§‹ä½ç½®
        ç»´åˆ—æ–¯Version: version,	  // ç»´åˆ—æ–¯ åè®®ç‰ˆæœ¬
        isUDP,					 // æ˜¯å¦æ˜¯ UDP è¯·æ±‚
    };
}

async function remoteSocketToWS(remoteSocket, webSocket, ç»´åˆ—æ–¯ResponseHeader, retry, log) {
    // å°†æ•°æ®ä»è¿œç¨‹æœåŠ¡å™¨è½¬å‘åˆ° WebSocket
    let remoteChunkCount = 0;
    let chunks = [];
    /** @type {ArrayBuffer | null} */
    let ç»´åˆ—æ–¯Header = ç»´åˆ—æ–¯ResponseHeader;
    let hasIncomingData = false; // æ£€æŸ¥è¿œç¨‹ Socket æ˜¯å¦æœ‰ä¼ å…¥æ•°æ®

    // ä½¿ç”¨ç®¡é“å°†è¿œç¨‹ Socket çš„å¯è¯»æµè¿æ¥åˆ°ä¸€ä¸ªå¯å†™æµ
    await remoteSocket.readable
        .pipeTo(
            new WritableStream({
                start() {
                    // åˆå§‹åŒ–æ—¶ä¸éœ€è¦ä»»ä½•æ“ä½œ
                },
                /**
                 * å¤„ç†æ¯ä¸ªæ•°æ®å—
                 * @param {Uint8Array} chunk æ•°æ®å—
                 * @param {*} controller æ§åˆ¶å™¨
                 */
                async write(chunk, controller) {
                    hasIncomingData = true; // æ ‡è®°å·²æ”¶åˆ°æ•°æ®
                    // remoteChunkCount++; // ç”¨äºæµé‡æ§åˆ¶ï¼Œç°åœ¨ä¼¼ä¹ä¸éœ€è¦äº†

                    // æ£€æŸ¥ WebSocket æ˜¯å¦å¤„äºå¼€æ”¾çŠ¶æ€
                    if (webSocket.readyState !== WS_READY_STATE_OPEN) {
                        controller.error(
                            'webSocket.readyState is not open, maybe close'
                        );
                    }

                    if (ç»´åˆ—æ–¯Header) {
                        // å¦‚æœæœ‰ ç»´åˆ—æ–¯ å“åº”å¤´éƒ¨ï¼Œå°†å…¶ä¸ç¬¬ä¸€ä¸ªæ•°æ®å—ä¸€èµ·å‘é€
                        webSocket.send(await new Blob([ç»´åˆ—æ–¯Header, chunk]).arrayBuffer());
                        ç»´åˆ—æ–¯Header = null; // æ¸…ç©ºå¤´éƒ¨ï¼Œä¹‹åä¸å†å‘é€
                    } else {
                        // ç›´æ¥å‘é€æ•°æ®å—
                        // ä»¥å‰è¿™é‡Œæœ‰æµé‡æ§åˆ¶ä»£ç ï¼Œé™åˆ¶å¤§é‡æ•°æ®çš„å‘é€é€Ÿç‡
                        // ä½†ç°åœ¨ Cloudflare ä¼¼ä¹å·²ç»ä¿®å¤äº†è¿™ä¸ªé—®é¢˜
                        // if (remoteChunkCount > 20000) {
                        // 	// cf one package is 4096 byte(4kb),  4096 * 20000 = 80M
                        // 	await delay(1);
                        // }
                        webSocket.send(chunk);
                    }
                },
                close() {
                    // å½“è¿œç¨‹è¿æ¥çš„å¯è¯»æµå…³é—­æ—¶
                    log(`remoteConnection!.readable is close with hasIncomingData is ${hasIncomingData}`);
                    // ä¸éœ€è¦ä¸»åŠ¨å…³é—­ WebSocketï¼Œå› ä¸ºè¿™å¯èƒ½å¯¼è‡´ HTTP ERR_CONTENT_LENGTH_MISMATCH é—®é¢˜
                    // å®¢æˆ·ç«¯æ— è®ºå¦‚ä½•éƒ½ä¼šå‘é€å…³é—­äº‹ä»¶
                    // safeCloseWebSocket(webSocket);
                },
                abort(reason) {
                    // å½“è¿œç¨‹è¿æ¥çš„å¯è¯»æµä¸­æ–­æ—¶
                    console.error(`remoteConnection!.readable abort`, reason);
                },
            })
        )
        .catch((error) => {
            // æ•è·å¹¶è®°å½•ä»»ä½•å¼‚å¸¸
            console.error(
                `remoteSocketToWS has exception `,
                error.stack || error
            );
            // å‘ç”Ÿé”™è¯¯æ—¶å®‰å…¨åœ°å…³é—­ WebSocket
            safeCloseWebSocket(webSocket);
        });

    // å¤„ç† Cloudflare è¿æ¥ Socket çš„ç‰¹æ®Šé”™è¯¯æƒ…å†µ
    // 1. Socket.closed å°†æœ‰é”™è¯¯
    // 2. Socket.readable å°†å…³é—­ï¼Œä½†æ²¡æœ‰ä»»ä½•æ•°æ®
    if (hasIncomingData === false && retry) {
        log(`retry`);
        retry(); // è°ƒç”¨é‡è¯•å‡½æ•°ï¼Œå°è¯•é‡æ–°å»ºç«‹è¿æ¥
    }
}

/**
 * å°† Base64 ç¼–ç çš„å­—ç¬¦ä¸²è½¬æ¢ä¸º ArrayBuffer
 * 
 * @param {string} base64Str Base64 ç¼–ç çš„è¾“å…¥å­—ç¬¦ä¸²
 * @returns {{ earlyData: ArrayBuffer | undefined, error: Error | null }} è¿”å›è§£ç åçš„ ArrayBuffer æˆ–é”™è¯¯
 */
function base64ToArrayBuffer(base64Str) {
    // å¦‚æœè¾“å…¥ä¸ºç©ºï¼Œç›´æ¥è¿”å›ç©ºç»“æœ
    if (!base64Str) {
        return { earlyData: undefined, error: null };
    }
    try {
        // Go è¯­è¨€ä½¿ç”¨äº† URL å®‰å…¨çš„ Base64 å˜ä½“ï¼ˆRFC 4648ï¼‰
        // è¿™ç§å˜ä½“ä½¿ç”¨ '-' å’Œ '_' æ¥ä»£æ›¿æ ‡å‡† Base64 ä¸­çš„ '+' å’Œ '/'
        // JavaScript çš„ atob å‡½æ•°ä¸ç›´æ¥æ”¯æŒè¿™ç§å˜ä½“ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦å…ˆè½¬æ¢
        base64Str = base64Str.replace(/-/g, '+').replace(/_/g, '/');

        // ä½¿ç”¨ atob å‡½æ•°è§£ç  Base64 å­—ç¬¦ä¸²
        // atob å°† Base64 ç¼–ç çš„ ASCII å­—ç¬¦ä¸²è½¬æ¢ä¸ºåŸå§‹çš„äºŒè¿›åˆ¶å­—ç¬¦ä¸²
        const decode = atob(base64Str);

        // å°†äºŒè¿›åˆ¶å­—ç¬¦ä¸²è½¬æ¢ä¸º Uint8Array
        // è¿™æ˜¯é€šè¿‡éå†å­—ç¬¦ä¸²ä¸­çš„æ¯ä¸ªå­—ç¬¦å¹¶è·å–å…¶ Unicode ç¼–ç å€¼ï¼ˆ0-255ï¼‰æ¥å®Œæˆçš„
        const arryBuffer = Uint8Array.from(decode, (c) => c.charCodeAt(0));

        // è¿”å› Uint8Array çš„åº•å±‚ ArrayBuffer
        // è¿™æ˜¯å®é™…çš„äºŒè¿›åˆ¶æ•°æ®ï¼Œå¯ä»¥ç”¨äºç½‘ç»œä¼ è¾“æˆ–å…¶ä»–äºŒè¿›åˆ¶æ“ä½œ
        return { earlyData: arryBuffer.buffer, error: null };
    } catch (error) {
        // å¦‚æœåœ¨ä»»ä½•æ­¥éª¤ä¸­å‡ºç°é”™è¯¯ï¼ˆå¦‚éæ³• Base64 å­—ç¬¦ï¼‰ï¼Œåˆ™è¿”å›é”™è¯¯
        return { earlyData: undefined, error };
    }
}

/**
 * è¿™ä¸æ˜¯çœŸæ­£çš„ UUID éªŒè¯ï¼Œè€Œæ˜¯ä¸€ä¸ªç®€åŒ–çš„ç‰ˆæœ¬
 * @param {string} uuid è¦éªŒè¯çš„ UUID å­—ç¬¦ä¸²
 * @returns {boolean} å¦‚æœå­—ç¬¦ä¸²åŒ¹é… UUID æ ¼å¼åˆ™è¿”å› trueï¼Œå¦åˆ™è¿”å› false
 */
function isValidUUID(uuid) {
    // å®šä¹‰ä¸€ä¸ªæ­£åˆ™è¡¨è¾¾å¼æ¥åŒ¹é… UUID æ ¼å¼
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;

    // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æµ‹è¯• UUID å­—ç¬¦ä¸²
    return uuidRegex.test(uuid);
}

// WebSocket çš„ä¸¤ä¸ªé‡è¦çŠ¶æ€å¸¸é‡
const WS_READY_STATE_OPEN = 1;	 // WebSocket å¤„äºå¼€æ”¾çŠ¶æ€ï¼Œå¯ä»¥å‘é€å’Œæ¥æ”¶æ¶ˆæ¯
const WS_READY_STATE_CLOSING = 2;  // WebSocket æ­£åœ¨å…³é—­è¿‡ç¨‹ä¸­

function safeCloseWebSocket(socket) {
    try {
        // åªæœ‰åœ¨ WebSocket å¤„äºå¼€æ”¾æˆ–æ­£åœ¨å…³é—­çŠ¶æ€æ—¶æ‰è°ƒç”¨ close()
        // è¿™é¿å…äº†åœ¨å·²å…³é—­æˆ–è¿æ¥ä¸­çš„ WebSocket ä¸Šè°ƒç”¨ close()
        if (socket.readyState === WS_READY_STATE_OPEN || socket.readyState === WS_READY_STATE_CLOSING) {
            socket.close();
        }
    } catch (error) {
        // è®°å½•ä»»ä½•å¯èƒ½å‘ç”Ÿçš„é”™è¯¯ï¼Œè™½ç„¶æŒ‰ç…§è§„èŒƒä¸åº”è¯¥æœ‰é”™è¯¯
        console.error('safeCloseWebSocket error', error);
    }
}

// é¢„è®¡ç®— 0-255 æ¯ä¸ªå­—èŠ‚çš„åå…­è¿›åˆ¶è¡¨ç¤º
const byteToHex = [];
for (let i = 0; i < 256; ++i) {
    // (i + 256).toString(16) ç¡®ä¿æ€»æ˜¯å¾—åˆ°ä¸¤ä½æ•°çš„åå…­è¿›åˆ¶
    // .slice(1) åˆ é™¤å‰å¯¼çš„ "1"ï¼Œåªä¿ç•™ä¸¤ä½åå…­è¿›åˆ¶æ•°
    byteToHex.push((i + 256).toString(16).slice(1));
}

/**
 * å¿«é€Ÿåœ°å°†å­—èŠ‚æ•°ç»„è½¬æ¢ä¸º UUID å­—ç¬¦ä¸²ï¼Œä¸è¿›è¡Œæœ‰æ•ˆæ€§æ£€æŸ¥
 * è¿™æ˜¯ä¸€ä¸ªåº•å±‚å‡½æ•°ï¼Œç›´æ¥æ“ä½œå­—èŠ‚ï¼Œä¸åšä»»ä½•éªŒè¯
 * @param {Uint8Array} arr åŒ…å« UUID å­—èŠ‚çš„æ•°ç»„
 * @param {number} offset æ•°ç»„ä¸­ UUID å¼€å§‹çš„ä½ç½®ï¼Œé»˜è®¤ä¸º 0
 * @returns {string} UUID å­—ç¬¦ä¸²
 */
function unsafeStringify(arr, offset = 0) {
    // ç›´æ¥ä»æŸ¥æ‰¾è¡¨ä¸­è·å–æ¯ä¸ªå­—èŠ‚çš„åå…­è¿›åˆ¶è¡¨ç¤ºï¼Œå¹¶æ‹¼æ¥æˆ UUID æ ¼å¼
    // 8-4-4-4-12 çš„åˆ†ç»„æ˜¯é€šè¿‡ç²¾å¿ƒæ”¾ç½®çš„è¿å­—ç¬¦ "-" å®ç°çš„
    // toLowerCase() ç¡®ä¿æ•´ä¸ª UUID æ˜¯å°å†™çš„
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" +
        byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" +
        byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" +
        byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" +
        byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] +
        byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

/**
 * å°†å­—èŠ‚æ•°ç»„è½¬æ¢ä¸º UUID å­—ç¬¦ä¸²ï¼Œå¹¶éªŒè¯å…¶æœ‰æ•ˆæ€§
 * è¿™æ˜¯ä¸€ä¸ªå®‰å…¨çš„å‡½æ•°ï¼Œå®ƒç¡®ä¿è¿”å›çš„ UUID æ ¼å¼æ­£ç¡®
 * @param {Uint8Array} arr åŒ…å« UUID å­—èŠ‚çš„æ•°ç»„
 * @param {number} offset æ•°ç»„ä¸­ UUID å¼€å§‹çš„ä½ç½®ï¼Œé»˜è®¤ä¸º 0
 * @returns {string} æœ‰æ•ˆçš„ UUID å­—ç¬¦ä¸²
 * @throws {TypeError} å¦‚æœç”Ÿæˆçš„ UUID å­—ç¬¦ä¸²æ— æ•ˆ
 */
function stringify(arr, offset = 0) {
    // ä½¿ç”¨ä¸å®‰å…¨çš„å‡½æ•°å¿«é€Ÿç”Ÿæˆ UUID å­—ç¬¦ä¸²
    const uuid = unsafeStringify(arr, offset);
    // éªŒè¯ç”Ÿæˆçš„ UUID æ˜¯å¦æœ‰æ•ˆ
    if (!isValidUUID(uuid)) {
        // åŸï¼šthrow TypeError("Stringified UUID is invalid");
        throw TypeError(`ç”Ÿæˆçš„ UUID ä¸ç¬¦åˆè§„èŒƒ ${uuid}`);
        //uuid = userID;
    }
    return uuid;
}

/**
 * 
 * @param {import("@cloudflare/workers-types").WebSocket} webSocket 
 * @param {ArrayBuffer} ç»´åˆ—æ–¯ResponseHeader 
 * @param {(string)=> void} log 
 */
async function handleUDPOutBound(webSocket, ç»´åˆ—æ–¯ResponseHeader, log) {

    let isç»´åˆ—æ–¯HeaderSent = false;
    const transformStream = new TransformStream({
        start(controller) {

        },
        transform(chunk, controller) {
            // udp message 2 byte is the the length of udp data
            // TODO: this should have bug, beacsue maybe udp chunk can be in two websocket message
            for (let index = 0; index < chunk.byteLength;) {
                const lengthBuffer = chunk.slice(index, index + 2);
                const udpPakcetLength = new DataView(lengthBuffer).getUint16(0);
                const udpData = new Uint8Array(
                    chunk.slice(index + 2, index + 2 + udpPakcetLength)
                );
                index = index + 2 + udpPakcetLength;
                controller.enqueue(udpData);
            }
        },
        flush(controller) {
        }
    });

    // only handle dns udp for now
    transformStream.readable.pipeTo(new WritableStream({
        async write(chunk) {
            const resp = await fetch('https://1.1.1.1/dns-query',
                {
                    method: 'POST',
                    headers: {
                        'content-type': 'application/dns-message',
                    },
                    body: chunk,
                })
            const dnsQueryResult = await resp.arrayBuffer();
            const udpSize = dnsQueryResult.byteLength;
            // console.log([...new Uint8Array(dnsQueryResult)].map((x) => x.toString(16)));
            const udpSizeBuffer = new Uint8Array([(udpSize >> 8) & 0xff, udpSize & 0xff]);
            if (webSocket.readyState === WS_READY_STATE_OPEN) {
                log(`doh success and dns message length is ${udpSize}`);
                if (isç»´åˆ—æ–¯HeaderSent) {
                    webSocket.send(await new Blob([udpSizeBuffer, dnsQueryResult]).arrayBuffer());
                } else {
                    webSocket.send(await new Blob([ç»´åˆ—æ–¯ResponseHeader, udpSizeBuffer, dnsQueryResult]).arrayBuffer());
                    isç»´åˆ—æ–¯HeaderSent = true;
                }
            }
        }
    })).catch((error) => {
        log('dns udp has error' + error)
    });

    const writer = transformStream.writable.getWriter();

    return {
        /**
         * 
         * @param {Uint8Array} chunk 
         */
        write(chunk) {
            writer.write(chunk);
        }
    };
}

/**
 * å¤„ç† DNS æŸ¥è¯¢çš„å‡½æ•°
 * @param {ArrayBuffer} udpChunk - å®¢æˆ·ç«¯å‘é€çš„ DNS æŸ¥è¯¢æ•°æ®
 * @param {ArrayBuffer} ç»´åˆ—æ–¯ResponseHeader - ç»´åˆ—æ–¯ åè®®çš„å“åº”å¤´éƒ¨æ•°æ®
 * @param {(string)=> void} log - æ—¥å¿—è®°å½•å‡½æ•°
 */
async function handleDNSQuery(udpChunk, webSocket, ç»´åˆ—æ–¯ResponseHeader, log) {
    // æ— è®ºå®¢æˆ·ç«¯å‘é€åˆ°å“ªä¸ª DNS æœåŠ¡å™¨ï¼Œæˆ‘ä»¬æ€»æ˜¯ä½¿ç”¨ç¡¬ç¼–ç çš„æœåŠ¡å™¨
    // å› ä¸ºæœ‰äº› DNS æœåŠ¡å™¨ä¸æ”¯æŒ DNS over TCP
    try {
        // é€‰ç”¨ Google çš„ DNS æœåŠ¡å™¨ï¼ˆæ³¨ï¼šåç»­å¯èƒ½ä¼šæ”¹ä¸º Cloudflare çš„ 1.1.1.1ï¼‰
        const dnsServer = '8.8.4.4'; // åœ¨ Cloudflare ä¿®å¤è¿æ¥è‡ªèº« IP çš„ bug åï¼Œå°†æ”¹ä¸º 1.1.1.1
        const dnsPort = 53; // DNS æœåŠ¡çš„æ ‡å‡†ç«¯å£

        let ç»´åˆ—æ–¯Header = ç»´åˆ—æ–¯ResponseHeader; // ä¿å­˜ ç»´åˆ—æ–¯ å“åº”å¤´éƒ¨ï¼Œç”¨äºåç»­å‘é€

        // ä¸æŒ‡å®šçš„ DNS æœåŠ¡å™¨å»ºç«‹ TCP è¿æ¥
        const tcpSocket = connect({
            hostname: dnsServer,
            port: dnsPort,
        });

        log(`è¿æ¥åˆ° ${dnsServer}:${dnsPort}`); // è®°å½•è¿æ¥ä¿¡æ¯
        const writer = tcpSocket.writable.getWriter();
        await writer.write(udpChunk); // å°†å®¢æˆ·ç«¯çš„ DNS æŸ¥è¯¢æ•°æ®å‘é€ç»™ DNS æœåŠ¡å™¨
        writer.releaseLock(); // é‡Šæ”¾å†™å…¥å™¨ï¼Œå…è®¸å…¶ä»–éƒ¨åˆ†ä½¿ç”¨

        // å°†ä» DNS æœåŠ¡å™¨æ¥æ”¶åˆ°çš„å“åº”æ•°æ®é€šè¿‡ WebSocket å‘é€å›å®¢æˆ·ç«¯
        await tcpSocket.readable.pipeTo(new WritableStream({
            async write(chunk) {
                if (webSocket.readyState === WS_READY_STATE_OPEN) {
                    if (ç»´åˆ—æ–¯Header) {
                        // å¦‚æœæœ‰ ç»´åˆ—æ–¯ å¤´éƒ¨ï¼Œåˆ™å°†å…¶ä¸ DNS å“åº”æ•°æ®åˆå¹¶åå‘é€
                        webSocket.send(await new Blob([ç»´åˆ—æ–¯Header, chunk]).arrayBuffer());
                        ç»´åˆ—æ–¯Header = null; // å¤´éƒ¨åªå‘é€ä¸€æ¬¡ï¼Œä¹‹åç½®ä¸º null
                    } else {
                        // å¦åˆ™ç›´æ¥å‘é€ DNS å“åº”æ•°æ®
                        webSocket.send(chunk);
                    }
                }
            },
            close() {
                log(`DNS æœåŠ¡å™¨(${dnsServer}) TCP è¿æ¥å·²å…³é—­`); // è®°å½•è¿æ¥å…³é—­ä¿¡æ¯
            },
            abort(reason) {
                console.error(`DNS æœåŠ¡å™¨(${dnsServer}) TCP è¿æ¥å¼‚å¸¸ä¸­æ–­`, reason); // è®°å½•å¼‚å¸¸ä¸­æ–­åŸå› 
            },
        }));
    } catch (error) {
        // æ•è·å¹¶è®°å½•ä»»ä½•å¯èƒ½å‘ç”Ÿçš„é”™è¯¯
        console.error(
            `handleDNSQuery å‡½æ•°å‘ç”Ÿå¼‚å¸¸ï¼Œé”™è¯¯ä¿¡æ¯: ${error.message}`
        );
    }
}

/**
 * å»ºç«‹ SOCKS5 ä»£ç†è¿æ¥
 * @param {number} addressType ç›®æ ‡åœ°å€ç±»å‹ï¼ˆ1: IPv4, 2: åŸŸå, 3: IPv6ï¼‰
 * @param {string} addressRemote ç›®æ ‡åœ°å€ï¼ˆå¯ä»¥æ˜¯ IP æˆ–åŸŸåï¼‰
 * @param {number} portRemote ç›®æ ‡ç«¯å£
 * @param {function} log æ—¥å¿—è®°å½•å‡½æ•°
 */
async function socks5Connect(addressType, addressRemote, portRemote, log) {
    const { username, password, hostname, port } = parsedSocks5Address;
    // è¿æ¥åˆ° SOCKS5 ä»£ç†æœåŠ¡å™¨
    const socket = connect({
        hostname, // SOCKS5 æœåŠ¡å™¨çš„ä¸»æœºå
        port,	// SOCKS5 æœåŠ¡å™¨çš„ç«¯å£
    });

    // è¯·æ±‚å¤´æ ¼å¼ï¼ˆWorker -> SOCKS5 æœåŠ¡å™¨ï¼‰:
    // +----+----------+----------+
    // |VER | NMETHODS | METHODS  |
    // +----+----------+----------+
    // | 1  |	1	 | 1 to 255 |
    // +----+----------+----------+

    // https://en.wikipedia.org/wiki/SOCKS#SOCKS5
    // METHODS å­—æ®µçš„å«ä¹‰:
    // 0x00 ä¸éœ€è¦è®¤è¯
    // 0x02 ç”¨æˆ·å/å¯†ç è®¤è¯ https://datatracker.ietf.org/doc/html/rfc1929
    const socksGreeting = new Uint8Array([5, 2, 0, 2]);
    // 5: SOCKS5 ç‰ˆæœ¬å·, 2: æ”¯æŒçš„è®¤è¯æ–¹æ³•æ•°, 0å’Œ2: ä¸¤ç§è®¤è¯æ–¹æ³•ï¼ˆæ— è®¤è¯å’Œç”¨æˆ·å/å¯†ç ï¼‰

    const writer = socket.writable.getWriter();

    await writer.write(socksGreeting);
    log('å·²å‘é€ SOCKS5 é—®å€™æ¶ˆæ¯');

    const reader = socket.readable.getReader();
    const encoder = new TextEncoder();
    let res = (await reader.read()).value;
    // å“åº”æ ¼å¼ï¼ˆSOCKS5 æœåŠ¡å™¨ -> Workerï¼‰:
    // +----+--------+
    // |VER | METHOD |
    // +----+--------+
    // | 1  |   1	|
    // +----+--------+
    if (res[0] !== 0x05) {
        log(`SOCKS5 æœåŠ¡å™¨ç‰ˆæœ¬é”™è¯¯: æ”¶åˆ° ${res[0]}ï¼ŒæœŸæœ›æ˜¯ 5`);
        return;
    }
    if (res[1] === 0xff) {
        log("æœåŠ¡å™¨ä¸æ¥å—ä»»ä½•è®¤è¯æ–¹æ³•");
        return;
    }

    // å¦‚æœè¿”å› 0x0502ï¼Œè¡¨ç¤ºéœ€è¦ç”¨æˆ·å/å¯†ç è®¤è¯
    if (res[1] === 0x02) {
        log("SOCKS5 æœåŠ¡å™¨éœ€è¦è®¤è¯");
        if (!username || !password) {
            log("è¯·æä¾›ç”¨æˆ·åå’Œå¯†ç ");
            return;
        }
        // è®¤è¯è¯·æ±‚æ ¼å¼:
        // +----+------+----------+------+----------+
        // |VER | ULEN |  UNAME   | PLEN |  PASSWD  |
        // +----+------+----------+------+----------+
        // | 1  |  1   | 1 to 255 |  1   | 1 to 255 |
        // +----+------+----------+------+----------+
        const authRequest = new Uint8Array([
            1,				   // è®¤è¯å­åè®®ç‰ˆæœ¬
            username.length,	// ç”¨æˆ·åé•¿åº¦
            ...encoder.encode(username), // ç”¨æˆ·å
            password.length,	// å¯†ç é•¿åº¦
            ...encoder.encode(password)  // å¯†ç 
        ]);
        await writer.write(authRequest);
        res = (await reader.read()).value;
        // æœŸæœ›è¿”å› 0x0100 è¡¨ç¤ºè®¤è¯æˆåŠŸ
        if (res[0] !== 0x01 || res[1] !== 0x00) {
            log("SOCKS5 æœåŠ¡å™¨è®¤è¯å¤±è´¥");
            return;
        }
    }

    // è¯·æ±‚æ•°æ®æ ¼å¼ï¼ˆWorker -> SOCKS5 æœåŠ¡å™¨ï¼‰:
    // +----+-----+-------+------+----------+----------+
    // |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |
    // +----+-----+-------+------+----------+----------+
    // | 1  |  1  | X'00' |  1   | Variable |	2	 |
    // +----+-----+-------+------+----------+----------+
    // ATYP: åœ°å€ç±»å‹
    // 0x01: IPv4 åœ°å€
    // 0x03: åŸŸå
    // 0x04: IPv6 åœ°å€
    // DST.ADDR: ç›®æ ‡åœ°å€
    // DST.PORT: ç›®æ ‡ç«¯å£ï¼ˆç½‘ç»œå­—èŠ‚åºï¼‰

    // addressType
    // 1 --> IPv4  åœ°å€é•¿åº¦ = 4
    // 2 --> åŸŸå
    // 3 --> IPv6  åœ°å€é•¿åº¦ = 16
    let DSTADDR;	// DSTADDR = ATYP + DST.ADDR
    switch (addressType) {
        case 1: // IPv4
            DSTADDR = new Uint8Array(
                [1, ...addressRemote.split('.').map(Number)]
            );
            break;
        case 2: // åŸŸå
            DSTADDR = new Uint8Array(
                [3, addressRemote.length, ...encoder.encode(addressRemote)]
            );
            break;
        case 3: // IPv6
            DSTADDR = new Uint8Array(
                [4, ...addressRemote.split(':').flatMap(x => [parseInt(x.slice(0, 2), 16), parseInt(x.slice(2), 16)])]
            );
            break;
        default:
            log(`æ— æ•ˆçš„åœ°å€ç±»å‹: ${addressType}`);
            return;
    }
    const socksRequest = new Uint8Array([5, 1, 0, ...DSTADDR, portRemote >> 8, portRemote & 0xff]);
    // 5: SOCKS5ç‰ˆæœ¬, 1: è¡¨ç¤ºCONNECTè¯·æ±‚, 0: ä¿ç•™å­—æ®µ
    // ...DSTADDR: ç›®æ ‡åœ°å€, portRemote >> 8 å’Œ & 0xff: å°†ç«¯å£è½¬ä¸ºç½‘ç»œå­—èŠ‚åº
    await writer.write(socksRequest);
    log('å·²å‘é€ SOCKS5 è¯·æ±‚');

    res = (await reader.read()).value;
    // å“åº”æ ¼å¼ï¼ˆSOCKS5 æœåŠ¡å™¨ -> Workerï¼‰:
    //  +----+-----+-------+------+----------+----------+
    // |VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |
    // +----+-----+-------+------+----------+----------+
    // | 1  |  1  | X'00' |  1   | Variable |	2	 |
    // +----+-----+-------+------+----------+----------+
    if (res[1] === 0x00) {
        log("SOCKS5 è¿æ¥å·²å»ºç«‹");
    } else {
        log("SOCKS5 è¿æ¥å»ºç«‹å¤±è´¥");
        return;
    }
    writer.releaseLock();
    reader.releaseLock();
    return socket;
}

/**
 * å»ºç«‹ HTTP ä»£ç†è¿æ¥
 * @param {string} addressRemote ç›®æ ‡åœ°å€ï¼ˆå¯ä»¥æ˜¯ IP æˆ–åŸŸåï¼‰
 * @param {number} portRemote ç›®æ ‡ç«¯å£
 * @param {function} log æ—¥å¿—è®°å½•å‡½æ•°
 */
async function httpConnect(addressRemote, portRemote, log) {
    const { username, password, hostname, port } = parsedSocks5Address;
    const sock = await connect({
        hostname: hostname,
        port: port
    });

    // æ„å»ºHTTP CONNECTè¯·æ±‚
    let connectRequest = `CONNECT ${addressRemote}:${portRemote} HTTP/1.1\r\n`;
    connectRequest += `Host: ${addressRemote}:${portRemote}\r\n`;

    // æ·»åŠ ä»£ç†è®¤è¯ï¼ˆå¦‚æœéœ€è¦ï¼‰
    if (username && password) {
        const authString = `${username}:${password}`;
        const base64Auth = btoa(authString);
        connectRequest += `Proxy-Authorization: Basic ${base64Auth}\r\n`;
    }

    connectRequest += `User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\r\n`;
    connectRequest += `Proxy-Connection: Keep-Alive\r\n`;
    connectRequest += `Connection: Keep-Alive\r\n`; // æ·»åŠ æ ‡å‡† Connection å¤´
    connectRequest += `\r\n`;

    log(`æ­£åœ¨è¿æ¥åˆ° ${addressRemote}:${portRemote} é€šè¿‡ä»£ç† ${hostname}:${port}`);

    try {
        // å‘é€è¿æ¥è¯·æ±‚
        const writer = sock.writable.getWriter();
        await writer.write(new TextEncoder().encode(connectRequest));
        writer.releaseLock();
    } catch (err) {
        console.error('å‘é€HTTP CONNECTè¯·æ±‚å¤±è´¥:', err);
        throw new Error(`å‘é€HTTP CONNECTè¯·æ±‚å¤±è´¥: ${err.message}`);
    }

    // è¯»å–HTTPå“åº”
    const reader = sock.readable.getReader();
    let respText = '';
    let connected = false;
    let responseBuffer = new Uint8Array(0);

    try {
        while (true) {
            const { value, done } = await reader.read();
            if (done) {
                console.error('HTTPä»£ç†è¿æ¥ä¸­æ–­');
                throw new Error('HTTPä»£ç†è¿æ¥ä¸­æ–­');
            }

            // åˆå¹¶æ¥æ”¶åˆ°çš„æ•°æ®
            const newBuffer = new Uint8Array(responseBuffer.length + value.length);
            newBuffer.set(responseBuffer);
            newBuffer.set(value, responseBuffer.length);
            responseBuffer = newBuffer;

            // å°†æ”¶åˆ°çš„æ•°æ®è½¬æ¢ä¸ºæ–‡æœ¬
            respText = new TextDecoder().decode(responseBuffer);

            // æ£€æŸ¥æ˜¯å¦æ”¶åˆ°å®Œæ•´çš„HTTPå“åº”å¤´
            if (respText.includes('\r\n\r\n')) {
                // åˆ†ç¦»HTTPå¤´å’Œå¯èƒ½çš„æ•°æ®éƒ¨åˆ†
                const headersEndPos = respText.indexOf('\r\n\r\n') + 4;
                const headers = respText.substring(0, headersEndPos);

                log(`æ”¶åˆ°HTTPä»£ç†å“åº”: ${headers.split('\r\n')[0]}`);

                // æ£€æŸ¥å“åº”çŠ¶æ€
                if (headers.startsWith('HTTP/1.1 200') || headers.startsWith('HTTP/1.0 200')) {
                    connected = true;

                    // å¦‚æœå“åº”å¤´ä¹‹åè¿˜æœ‰æ•°æ®ï¼Œæˆ‘ä»¬éœ€è¦ä¿å­˜è¿™äº›æ•°æ®ä»¥ä¾¿åç»­å¤„ç†
                    if (headersEndPos < responseBuffer.length) {
                        const remainingData = responseBuffer.slice(headersEndPos);
                        // åˆ›å»ºä¸€ä¸ªç¼“å†²åŒºæ¥å­˜å‚¨è¿™äº›æ•°æ®ï¼Œä»¥ä¾¿ç¨åä½¿ç”¨
                        const dataStream = new ReadableStream({
                            start(controller) {
                                controller.enqueue(remainingData);
                            }
                        });

                        // åˆ›å»ºä¸€ä¸ªæ–°çš„TransformStreamæ¥å¤„ç†é¢å¤–æ•°æ®
                        const { readable, writable } = new TransformStream();
                        dataStream.pipeTo(writable).catch(err => console.error('å¤„ç†å‰©ä½™æ•°æ®é”™è¯¯:', err));

                        // æ›¿æ¢åŸå§‹readableæµ
                        // @ts-ignore
                        sock.readable = readable;
                    }
                } else {
                    const errorMsg = `HTTPä»£ç†è¿æ¥å¤±è´¥: ${headers.split('\r\n')[0]}`;
                    console.error(errorMsg);
                    throw new Error(errorMsg);
                }
                break;
            }
        }
    } catch (err) {
        reader.releaseLock();
        throw new Error(`å¤„ç†HTTPä»£ç†å“åº”å¤±è´¥: ${err.message}`);
    }

    reader.releaseLock();

    if (!connected) {
        throw new Error('HTTPä»£ç†è¿æ¥å¤±è´¥: æœªæ”¶åˆ°æˆåŠŸå“åº”');
    }

    log(`HTTPä»£ç†è¿æ¥æˆåŠŸ: ${addressRemote}:${portRemote}`);
    return sock;
}

/**
 * SOCKS5 ä»£ç†åœ°å€è§£æå™¨
 * æ­¤å‡½æ•°ç”¨äºè§£æ SOCKS5 ä»£ç†åœ°å€å­—ç¬¦ä¸²ï¼Œæå–å‡ºç”¨æˆ·åã€å¯†ç ã€ä¸»æœºåå’Œç«¯å£å·
 * 
 * @param {string} address SOCKS5 ä»£ç†åœ°å€ï¼Œæ ¼å¼å¯ä»¥æ˜¯ï¼š
 *   - "username:password@hostname:port" ï¼ˆå¸¦è®¤è¯ï¼‰
 *   - "hostname:port" ï¼ˆä¸éœ€è®¤è¯ï¼‰
 *   - "username:password@[ipv6]:port" ï¼ˆIPv6 åœ°å€éœ€è¦ç”¨æ–¹æ‹¬å·æ‹¬èµ·æ¥ï¼‰
 */
function socks5AddressParser(address) {
    // ä½¿ç”¨ "@" åˆ†å‰²åœ°å€ï¼Œåˆ†ä¸ºè®¤è¯éƒ¨åˆ†å’ŒæœåŠ¡å™¨åœ°å€éƒ¨åˆ†
    const lastAtIndex = address.lastIndexOf("@");
    let [latter, former] = lastAtIndex === -1 ? [address, undefined] : [address.substring(lastAtIndex + 1), address.substring(0, lastAtIndex)];
    let username, password, hostname, port;

    // å¦‚æœå­˜åœ¨ former éƒ¨åˆ†ï¼Œè¯´æ˜æä¾›äº†è®¤è¯ä¿¡æ¯
    if (former) {
        const formers = former.split(":");
        if (formers.length !== 2) {
            throw new Error('æ— æ•ˆçš„ SOCKS åœ°å€æ ¼å¼ï¼šè®¤è¯éƒ¨åˆ†å¿…é¡»æ˜¯ "username:password" çš„å½¢å¼');
        }
        [username, password] = formers;
    }

    // è§£ææœåŠ¡å™¨åœ°å€éƒ¨åˆ†
    const latters = latter.split(":");
    // æ£€æŸ¥æ˜¯å¦æ˜¯IPv6åœ°å€å¸¦ç«¯å£æ ¼å¼ [xxx]:port
    if (latters.length > 2 && latter.includes("]:")) {
        // IPv6åœ°å€å¸¦ç«¯å£æ ¼å¼ï¼š[2001:db8::1]:8080
        port = Number(latter.split("]:")[1].replace(/[^\d]/g, ''));
        hostname = latter.split("]:")[0] + "]"; // æ­£ç¡®æå–hostnameéƒ¨åˆ†
    } else if (latters.length === 2) {
        // IPv4åœ°å€å¸¦ç«¯å£æˆ–åŸŸåå¸¦ç«¯å£
        port = Number(latters.pop().replace(/[^\d]/g, ''));
        hostname = latters.join(":");
    } else {
        port = 80;
        hostname = latter;
    }

    if (isNaN(port)) {
        throw new Error('æ— æ•ˆçš„ SOCKS åœ°å€æ ¼å¼ï¼šç«¯å£å·å¿…é¡»æ˜¯æ•°å­—');
    }

    // å¤„ç† IPv6 åœ°å€çš„ç‰¹æ®Šæƒ…å†µ
    // IPv6 åœ°å€åŒ…å«å¤šä¸ªå†’å·ï¼Œæ‰€ä»¥å¿…é¡»ç”¨æ–¹æ‹¬å·æ‹¬èµ·æ¥ï¼Œå¦‚ [2001:db8::1]
    const regex = /^\[.*\]$/;
    if (hostname.includes(":") && !regex.test(hostname)) {
        throw new Error('æ— æ•ˆçš„ SOCKS åœ°å€æ ¼å¼ï¼šIPv6 åœ°å€å¿…é¡»ç”¨æ–¹æ‹¬å·æ‹¬èµ·æ¥ï¼Œå¦‚ [2001:db8::1]');
    }

    //if (/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(hostname)) hostname = `${atob('d3d3Lg==')}${hostname}${atob('LmlwLjA5MDIyNy54eXo=')}`;
    // è¿”å›è§£æåçš„ç»“æœ
    return {
        username,  // ç”¨æˆ·åï¼Œå¦‚æœæ²¡æœ‰åˆ™ä¸º undefined
        password,  // å¯†ç ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä¸º undefined
        hostname,  // ä¸»æœºåï¼Œå¯ä»¥æ˜¯åŸŸåã€IPv4 æˆ– IPv6 åœ°å€
        port,	 // ç«¯å£å·ï¼Œå·²è½¬æ¢ä¸ºæ•°å­—ç±»å‹
    }
}

/**
 * æ¢å¤è¢«ä¼ªè£…çš„ä¿¡æ¯
 * è¿™ä¸ªå‡½æ•°ç”¨äºå°†å†…å®¹ä¸­çš„å‡ç”¨æˆ·IDå’Œå‡ä¸»æœºåæ›¿æ¢å›çœŸå®çš„å€¼
 * 
 * @param {string} content éœ€è¦å¤„ç†çš„å†…å®¹
 * @param {string} userID çœŸå®çš„ç”¨æˆ·ID
 * @param {string} hostName çœŸå®çš„ä¸»æœºå
 * @param {boolean} isBase64 å†…å®¹æ˜¯å¦æ˜¯Base64ç¼–ç çš„
 * @returns {string} æ¢å¤çœŸå®ä¿¡æ¯åçš„å†…å®¹
 */
function æ¢å¤ä¼ªè£…ä¿¡æ¯(content, userID, hostName, fakeUserID, fakeHostName, isBase64) {
    if (isBase64) content = atob(content);  // å¦‚æœå†…å®¹æ˜¯Base64ç¼–ç çš„ï¼Œå…ˆè§£ç 

    // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼å…¨å±€æ›¿æ¢ï¼ˆ'g'æ ‡å¿—ï¼‰
    // å°†æ‰€æœ‰å‡ºç°çš„å‡ç”¨æˆ·IDå’Œå‡ä¸»æœºåæ›¿æ¢ä¸ºçœŸå®çš„å€¼
    content = content.replace(new RegExp(fakeUserID, 'g'), userID)
        .replace(new RegExp(fakeHostName, 'g'), hostName);

    if (isBase64) content = btoa(content);  // å¦‚æœåŸå†…å®¹æ˜¯Base64ç¼–ç çš„ï¼Œå¤„ç†å®Œåå†æ¬¡ç¼–ç 

    return content;
}

/**
 * åŒé‡MD5å“ˆå¸Œå‡½æ•°
 * è¿™ä¸ªå‡½æ•°å¯¹è¾“å…¥æ–‡æœ¬è¿›è¡Œä¸¤æ¬¡MD5å“ˆå¸Œï¼Œå¢å¼ºå®‰å…¨æ€§
 * ç¬¬äºŒæ¬¡å“ˆå¸Œä½¿ç”¨ç¬¬ä¸€æ¬¡å“ˆå¸Œç»“æœçš„ä¸€éƒ¨åˆ†ä½œä¸ºè¾“å…¥
 * 
 * @param {string} æ–‡æœ¬ è¦å“ˆå¸Œçš„æ–‡æœ¬
 * @returns {Promise<string>} åŒé‡å“ˆå¸Œåçš„å°å†™åå…­è¿›åˆ¶å­—ç¬¦ä¸²
 */
async function åŒé‡å“ˆå¸Œ(æ–‡æœ¬) {
    const ç¼–ç å™¨ = new TextEncoder();

    const ç¬¬ä¸€æ¬¡å“ˆå¸Œ = await crypto.subtle.digest('MD5', ç¼–ç å™¨.encode(æ–‡æœ¬));
    const ç¬¬ä¸€æ¬¡å“ˆå¸Œæ•°ç»„ = Array.from(new Uint8Array(ç¬¬ä¸€æ¬¡å“ˆå¸Œ));
    const ç¬¬ä¸€æ¬¡åå…­è¿›åˆ¶ = ç¬¬ä¸€æ¬¡å“ˆå¸Œæ•°ç»„.map(å­—èŠ‚ => å­—èŠ‚.toString(16).padStart(2, '0')).join('');

    const ç¬¬äºŒæ¬¡å“ˆå¸Œ = await crypto.subtle.digest('MD5', ç¼–ç å™¨.encode(ç¬¬ä¸€æ¬¡åå…­è¿›åˆ¶.slice(7, 27)));
    const ç¬¬äºŒæ¬¡å“ˆå¸Œæ•°ç»„ = Array.from(new Uint8Array(ç¬¬äºŒæ¬¡å“ˆå¸Œ));
    const ç¬¬äºŒæ¬¡åå…­è¿›åˆ¶ = ç¬¬äºŒæ¬¡å“ˆå¸Œæ•°ç»„.map(å­—èŠ‚ => å­—èŠ‚.toString(16).padStart(2, '0')).join('');

    return ç¬¬äºŒæ¬¡åå…­è¿›åˆ¶.toLowerCase();
}

async function ä»£ç†URL(ä»£ç†ç½‘å€, ç›®æ ‡ç½‘å€) {
    const ç½‘å€åˆ—è¡¨ = await æ•´ç†(ä»£ç†ç½‘å€);
    const å®Œæ•´ç½‘å€ = ç½‘å€åˆ—è¡¨[Math.floor(Math.random() * ç½‘å€åˆ—è¡¨.length)];

    // è§£æç›®æ ‡ URL
    let è§£æåçš„ç½‘å€ = new URL(å®Œæ•´ç½‘å€);
    console.log(è§£æåçš„ç½‘å€);
    // æå–å¹¶å¯èƒ½ä¿®æ”¹ URL ç»„ä»¶
    let åè®® = è§£æåçš„ç½‘å€.protocol.slice(0, -1) || 'https';
    let ä¸»æœºå = è§£æåçš„ç½‘å€.hostname;
    let è·¯å¾„å = è§£æåçš„ç½‘å€.pathname;
    let æŸ¥è¯¢å‚æ•° = è§£æåçš„ç½‘å€.search;

    // å¤„ç†è·¯å¾„å
    if (è·¯å¾„å.charAt(è·¯å¾„å.length - 1) == '/') {
        è·¯å¾„å = è·¯å¾„å.slice(0, -1);
    }
    è·¯å¾„å += ç›®æ ‡ç½‘å€.pathname;

    // æ„å»ºæ–°çš„ URL
    let æ–°ç½‘å€ = `${åè®®}://${ä¸»æœºå}${è·¯å¾„å}${æŸ¥è¯¢å‚æ•°}`;

    // åå‘ä»£ç†è¯·æ±‚
    let å“åº” = await fetch(æ–°ç½‘å€);

    // åˆ›å»ºæ–°çš„å“åº”
    let æ–°å“åº” = new Response(å“åº”.body, {
        status: å“åº”.status,
        statusText: å“åº”.statusText,
        headers: å“åº”.headers
    });

    // æ·»åŠ è‡ªå®šä¹‰å¤´éƒ¨ï¼ŒåŒ…å« URL ä¿¡æ¯
    //æ–°å“åº”.headers.set('X-Proxied-By', 'Cloudflare Worker');
    //æ–°å“åº”.headers.set('X-Original-URL', å®Œæ•´ç½‘å€);
    æ–°å“åº”.headers.set('X-New-URL', æ–°ç½‘å€);

    return æ–°å“åº”;
}

const å•¥å•¥å•¥_å†™çš„è¿™æ˜¯å•¥å•Š = atob('ZG14bGMzTT0=');
function é…ç½®ä¿¡æ¯(UUID, åŸŸååœ°å€) {
    const åè®®ç±»å‹ = atob(å•¥å•¥å•¥_å†™çš„è¿™æ˜¯å•¥å•Š);

    const åˆ«å = FileName;
    let åœ°å€ = åŸŸååœ°å€;
    let ç«¯å£ = 443;

    const ç”¨æˆ·ID = UUID;
    const åŠ å¯†æ–¹å¼ = 'none';

    const ä¼ è¾“å±‚åè®® = 'ws';
    const ä¼ªè£…åŸŸå = åŸŸååœ°å€;
    const è·¯å¾„ = path;

    let ä¼ è¾“å±‚å®‰å…¨ = ['tls', true];
    const SNI = åŸŸååœ°å€;
    const æŒ‡çº¹ = 'randomized';

    if (åŸŸååœ°å€.includes('.workers.dev')) {
        åœ°å€ = atob('dmlzYS5jb20uaGs=');
        ç«¯å£ = 80;
        ä¼ è¾“å±‚å®‰å…¨ = ['', false];
    }

    const å¨å›¾ç‘ = `${åè®®ç±»å‹}://${ç”¨æˆ·ID}@${åœ°å€}:${ç«¯å£}\u003f\u0065\u006e\u0063\u0072\u0079` + 'p' + `${atob('dGlvbj0=') + åŠ å¯†æ–¹å¼}\u0026\u0073\u0065\u0063\u0075\u0072\u0069\u0074\u0079\u003d${ä¼ è¾“å±‚å®‰å…¨[0]}&sni=${SNI}&fp=${æŒ‡çº¹}&type=${ä¼ è¾“å±‚åè®®}&host=${ä¼ªè£…åŸŸå}&path=${encodeURIComponent(è·¯å¾„) + allowInsecure}&fragment=${encodeURIComponent('1,40-60,30-50,tlshello')}#${encodeURIComponent(åˆ«å)}`;
    const çŒ«çŒ«çŒ« = `- {name: ${FileName}, server: ${åœ°å€}, port: ${ç«¯å£}, type: ${åè®®ç±»å‹}, uuid: ${ç”¨æˆ·ID}, tls: ${ä¼ è¾“å±‚å®‰å…¨[1]}, alpn: [h3], udp: false, sni: ${SNI}, tfo: false, skip-cert-verify: ${SCV}, servername: ${ä¼ªè£…åŸŸå}, client-fingerprint: ${æŒ‡çº¹}, network: ${ä¼ è¾“å±‚åè®®}, ws-opts: {path: "${è·¯å¾„}", headers: {${ä¼ªè£…åŸŸå}}}}`;
    return [å¨å›¾ç‘, çŒ«çŒ«çŒ«];
}

let subParams = ['sub', 'base64', 'b64', 'clash', 'singbox', 'sb'];
const cmad = decodeURIComponent(atob('dGVsZWdyYW0lMjAlRTQlQkElQTQlRTYlQjUlODElRTclQkUlQTQlMjAlRTYlOEElODAlRTYlOUMlQUYlRTUlQTQlQTclRTQlQkQlQUMlN0UlRTUlOUMlQTglRTclQkElQkYlRTUlOEYlOTElRTclODklOEMhJTNDYnIlM0UKJTNDYSUyMGhyZWYlM0QlMjdodHRwcyUzQSUyRiUyRnQubWUlMkZDTUxpdXNzc3MlMjclM0VodHRwcyUzQSUyRiUyRnQubWUlMkZDTUxpdXNzc3MlM0MlMkZhJTNFJTNDYnIlM0UKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJTNDYnIlM0UKZ2l0aHViJTIwJUU5JUExJUI5JUU3JTlCJUFFJUU1JTlDJUIwJUU1JTlEJTgwJTIwU3RhciFTdGFyIVN0YXIhISElM0NiciUzRQolM0NhJTIwaHJlZiUzRCUyN2h0dHBzJTNBJTJGJTJGZ2l0aHViLmNvbSUyRmNtbGl1JTJGZWRnZXR1bm5lbCUyNyUzRWh0dHBzJTNBJTJGJTJGZ2l0aHViLmNvbSUyRmNtbGl1JTJGZWRnZXR1bm5lbCUzQyUyRmElM0UlM0NiciUzRQotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0lM0NiciUzRQolMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjMlMjM='));
/**
 * @param {string} userID
 * @param {string | null} hostName
 * @param {string} sub
 * @param {string} UA
 * @returns {Promise<string>}
 */
async function ç”Ÿæˆé…ç½®ä¿¡æ¯(userID, hostName, sub, UA, RproxyIP, _url, fakeUserID, fakeHostName, env) {
    if (sub) {
        const match = sub.match(/^(?:https?:\/\/)?([^\/]+)/);
        if (match) {
            sub = match[1];
        }
        const subs = await æ•´ç†(sub);
        if (subs.length > 1) sub = subs[0];
    } else {
        if (env.KV) {
            await è¿ç§»åœ°å€åˆ—è¡¨(env);
            const ä¼˜é€‰åœ°å€åˆ—è¡¨ = await env.KV.get('ADD.txt');
            if (ä¼˜é€‰åœ°å€åˆ—è¡¨) {
                const ä¼˜é€‰åœ°å€æ•°ç»„ = await æ•´ç†(ä¼˜é€‰åœ°å€åˆ—è¡¨);
                const åˆ†ç±»åœ°å€ = {
                    æ¥å£åœ°å€: new Set(),
                    é“¾æ¥åœ°å€: new Set(),
                    ä¼˜é€‰åœ°å€: new Set()
                };

                for (const å…ƒç´  of ä¼˜é€‰åœ°å€æ•°ç»„) {
                    if (å…ƒç´ .startsWith('https://')) {
                        åˆ†ç±»åœ°å€.æ¥å£åœ°å€.add(å…ƒç´ );
                    } else if (å…ƒç´ .includes('://')) {
                        åˆ†ç±»åœ°å€.é“¾æ¥åœ°å€.add(å…ƒç´ );
                    } else {
                        åˆ†ç±»åœ°å€.ä¼˜é€‰åœ°å€.add(å…ƒç´ );
                    }
                }

                addressesapi = [...åˆ†ç±»åœ°å€.æ¥å£åœ°å€];
                link = [...åˆ†ç±»åœ°å€.é“¾æ¥åœ°å€];
                addresses = [...åˆ†ç±»åœ°å€.ä¼˜é€‰åœ°å€];
            }
        }

        if ((addresses.length + addressesapi.length + addressesnotls.length + addressesnotlsapi.length + addressescsv.length) == 0) {
            // å®šä¹‰ Cloudflare IP èŒƒå›´çš„ CIDR åˆ—è¡¨
            let cfips = ['104.16.0.0/13'];
            // è¯·æ±‚ Cloudflare CIDR åˆ—è¡¨
            try {
                const response = await fetch('https://raw.githubusercontent.com/cmliu/cmliu/main/CF-CIDR.txt');
                if (response.ok) {
                    const data = await response.text();
                    cfips = await æ•´ç†(data);
                }
            } catch (error) {
                console.log('è·å– CF-CIDR å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å€¼:', error);
            }

            // ç”Ÿæˆç¬¦åˆç»™å®š CIDR èŒƒå›´çš„éšæœº IP åœ°å€
            function generateRandomIPFromCIDR(cidr) {
                const [base, mask] = cidr.split('/');
                const baseIP = base.split('.').map(Number);
                const subnetMask = 32 - parseInt(mask, 10);
                const maxHosts = Math.pow(2, subnetMask) - 1;
                const randomHost = Math.floor(Math.random() * maxHosts);

                const randomIP = baseIP.map((octet, index) => {
                    if (index < 2) return octet;
                    if (index === 2) return (octet & (255 << (subnetMask - 8))) + ((randomHost >> 8) & 255);
                    return (octet & (255 << subnetMask)) + (randomHost & 255);
                });

                return randomIP.join('.');
            }
            addresses = addresses.concat('127.0.0.1:1234#CFnat');
            let counter = 1;
            if (hostName.includes("worker") || hostName.includes("notls")) {
                const randomPorts = httpPorts.concat('80');
                addressesnotls = addressesnotls.concat(
                    cfips.map(cidr => generateRandomIPFromCIDR(cidr) + ':' + randomPorts[Math.floor(Math.random() * randomPorts.length)] + '#CFéšæœºèŠ‚ç‚¹' + String(counter++).padStart(2, '0'))
                );
            } else {
                const randomPorts = httpsPorts.concat('443');
                addresses = addresses.concat(
                    cfips.map(cidr => generateRandomIPFromCIDR(cidr) + ':' + randomPorts[Math.floor(Math.random() * randomPorts.length)] + '#CFéšæœºèŠ‚ç‚¹' + String(counter++).padStart(2, '0'))
                );
            }
        }
    }

    const uuid = (_url.pathname == `/${åŠ¨æ€UUID}`) ? åŠ¨æ€UUID : userID;
    const userAgent = UA.toLowerCase();
    const Config = é…ç½®ä¿¡æ¯(userID, hostName);
    const v2ray = Config[0];
    const clash = Config[1];
    let proxyhost = "";
    if (hostName.includes(".workers.dev")) {
        if (proxyhostsURL && (!proxyhosts || proxyhosts.length == 0)) {
            try {
                const response = await fetch(proxyhostsURL);

                if (!response.ok) {
                    console.error('è·å–åœ°å€æ—¶å‡ºé”™:', response.status, response.statusText);
                    return; // å¦‚æœæœ‰é”™è¯¯ï¼Œç›´æ¥è¿”å›
                }

                const text = await response.text();
                const lines = text.split('\n');
                // è¿‡æ»¤æ‰ç©ºè¡Œæˆ–åªåŒ…å«ç©ºç™½å­—ç¬¦çš„è¡Œ
                const nonEmptyLines = lines.filter(line => line.trim() !== '');

                proxyhosts = proxyhosts.concat(nonEmptyLines);
            } catch (error) {
                //console.error('è·å–åœ°å€æ—¶å‡ºé”™:', error);
            }
        }
        if (proxyhosts.length != 0) proxyhost = proxyhosts[Math.floor(Math.random() * proxyhosts.length)] + "/";
    }

    if (userAgent.includes('mozilla') && !subParams.some(_searchParams => _url.searchParams.has(_searchParams))) {
        const newSocks5s = socks5s.map(socks5Address => {
            if (socks5Address.includes('@')) return socks5Address.split('@')[1];
            else if (socks5Address.includes('//')) return socks5Address.split('//')[1];
            else return socks5Address;
        });

        let socks5List = '';
        if (go2Socks5s.length > 0 && enableSocks) {
            socks5List = `${(enableHttp ? "HTTP" : "Socks5") + decodeURIComponent('%EF%BC%88%E7%99%BD%E5%90%8D%E5%8D%95%EF%BC%89%3A%20')}`;
            if (go2Socks5s.includes(atob('YWxsIGlu')) || go2Socks5s.includes(atob('Kg=='))) socks5List += `${decodeURIComponent('%E6%89%80%E6%9C%89%E6%B5%81%E9%87%8F')}<br>`;
            else socks5List += `<br>&nbsp;&nbsp;${go2Socks5s.join('<br>&nbsp;&nbsp;')}<br>`;
        }

        let è®¢é˜…å™¨ = '<br>';
        if (sub) {
            if (enableSocks) è®¢é˜…å™¨ += `CFCDNï¼ˆè®¿é—®æ–¹å¼ï¼‰: ${enableHttp ? "HTTP" : "Socks5"}<br>&nbsp;&nbsp;${newSocks5s.join('<br>&nbsp;&nbsp;')}<br>${socks5List}`;
            else if (proxyIP && proxyIP != '') è®¢é˜…å™¨ += `CFCDNï¼ˆè®¿é—®æ–¹å¼ï¼‰: ProxyIP<br>&nbsp;&nbsp;${proxyIPs.join('<br>&nbsp;&nbsp;')}<br>`;
            else if (RproxyIP == 'true') è®¢é˜…å™¨ += `CFCDNï¼ˆè®¿é—®æ–¹å¼ï¼‰: è‡ªåŠ¨è·å–ProxyIP<br>`;
            else è®¢é˜…å™¨ += `CFCDNï¼ˆè®¿é—®æ–¹å¼ï¼‰: å†…ç½®å…œåº•, æ‚¨ä¹Ÿå¯ä»¥è®¾ç½® proxyIP/PROXYIP ã€‚<br>`
            è®¢é˜…å™¨ += `<br>SUBï¼ˆä¼˜é€‰è®¢é˜…ç”Ÿæˆå™¨ï¼‰: ${sub}`;
        } else {
            if (enableSocks) è®¢é˜…å™¨ += `CFCDNï¼ˆè®¿é—®æ–¹å¼ï¼‰: ${enableHttp ? "HTTP" : "Socks5"}<br>&nbsp;&nbsp;${newSocks5s.join('<br>&nbsp;&nbsp;')}<br>${socks5List}`;
            else if (proxyIP && proxyIP != '') è®¢é˜…å™¨ += `CFCDNï¼ˆè®¿é—®æ–¹å¼ï¼‰: ProxyIP<br>&nbsp;&nbsp;${proxyIPs.join('<br>&nbsp;&nbsp;')}<br>`;
            else è®¢é˜…å™¨ += `CFCDNï¼ˆè®¿é—®æ–¹å¼ï¼‰: å†…ç½®å…œåº•, æ‚¨ä¹Ÿå¯ä»¥è®¾ç½® proxyIP/PROXYIP ã€‚<br>`;
            let åˆ¤æ–­æ˜¯å¦ç»‘å®šKVç©ºé—´ = '';
            if (env.KV) åˆ¤æ–­æ˜¯å¦ç»‘å®šKVç©ºé—´ = ` [<a href='${_url.pathname}/edit'>ç¼–è¾‘ä¼˜é€‰åˆ—è¡¨</a>]  [<a href='${_url.pathname}/bestip'>åœ¨çº¿ä¼˜é€‰IP</a>]`;
            è®¢é˜…å™¨ += `<br>æ‚¨çš„è®¢é˜…å†…å®¹ç”± å†…ç½® addresses/ADD* å‚æ•°å˜é‡æä¾›${åˆ¤æ–­æ˜¯å¦ç»‘å®šKVç©ºé—´}<br>`;
            if (addresses.length > 0) è®¢é˜…å™¨ += `ADDï¼ˆTLSä¼˜é€‰åŸŸå&IPï¼‰: <br>&nbsp;&nbsp;${addresses.join('<br>&nbsp;&nbsp;')}<br>`;
            if (addressesnotls.length > 0) è®¢é˜…å™¨ += `ADDNOTLSï¼ˆnoTLSä¼˜é€‰åŸŸå&IPï¼‰: <br>&nbsp;&nbsp;${addressesnotls.join('<br>&nbsp;&nbsp;')}<br>`;
            if (addressesapi.length > 0) è®¢é˜…å™¨ += `ADDAPIï¼ˆTLSä¼˜é€‰åŸŸå&IP çš„ APIï¼‰: <br>&nbsp;&nbsp;${addressesapi.join('<br>&nbsp;&nbsp;')}<br>`;
            if (addressesnotlsapi.length > 0) è®¢é˜…å™¨ += `ADDNOTLSAPIï¼ˆnoTLSä¼˜é€‰åŸŸå&IP çš„ APIï¼‰: <br>&nbsp;&nbsp;${addressesnotlsapi.join('<br>&nbsp;&nbsp;')}<br>`;
            if (addressescsv.length > 0) è®¢é˜…å™¨ += `ADDCSVï¼ˆIPTestæµ‹é€Ÿcsvæ–‡ä»¶ é™é€Ÿ ${DLS} ï¼‰: <br>&nbsp;&nbsp;${addressescsv.join('<br>&nbsp;&nbsp;')}<br>`;
        }

        if (åŠ¨æ€UUID && _url.pathname !== `/${åŠ¨æ€UUID}`) è®¢é˜…å™¨ = '';
        else è®¢é˜…å™¨ += `<br>SUBAPIï¼ˆè®¢é˜…è½¬æ¢åç«¯ï¼‰: <a href='${subProtocol}://${subConverter}/version' target="_blank" rel="noopener noreferrer">${subProtocol}://${subConverter}</a><br>SUBCONFIGï¼ˆè®¢é˜…è½¬æ¢é…ç½®æ–‡ä»¶ï¼‰: <a href='${subConfig}' target="_blank" rel="noopener noreferrer">${subConfig}</a>`;
        const åŠ¨æ€UUIDä¿¡æ¯ = (uuid != userID) ? `TOKEN: ${uuid}<br>UUIDNow: ${userID}<br>UUIDLow: ${userIDLow}<br>${userIDTime}TIMEï¼ˆåŠ¨æ€UUIDæœ‰æ•ˆæ—¶é—´ï¼‰: ${æœ‰æ•ˆæ—¶é—´} å¤©<br>UPTIMEï¼ˆåŠ¨æ€UUIDæ›´æ–°æ—¶é—´ï¼‰: ${æ›´æ–°æ—¶é—´} æ—¶ï¼ˆåŒ—äº¬æ—¶é—´ï¼‰<br><br>` : `${userIDTime}`;
        const èŠ‚ç‚¹é…ç½®é¡µ = `
            ################################################################<br>
            Subscribe / sub è®¢é˜…åœ°å€, ç‚¹å‡»é“¾æ¥è‡ªåŠ¨ <strong>å¤åˆ¶è®¢é˜…é“¾æ¥</strong> å¹¶ <strong>ç”Ÿæˆè®¢é˜…äºŒç»´ç </strong> <br>
            ---------------------------------------------------------------<br>
            è‡ªé€‚åº”è®¢é˜…åœ°å€:<br>
            <a href="javascript:void(0)" onclick="copyToClipboard('https://${proxyhost}${hostName}/${uuid}?sub','qrcode_0')" style="color:blue;text-decoration:underline;cursor:pointer;">https://${proxyhost}${hostName}/${uuid}</a><br>
            <div id="qrcode_0" style="margin: 10px 10px 10px 10px;"></div>
            Base64è®¢é˜…åœ°å€:<br>
            <a href="javascript:void(0)" onclick="copyToClipboard('https://${proxyhost}${hostName}/${uuid}?b64','qrcode_1')" style="color:blue;text-decoration:underline;cursor:pointer;">https://${proxyhost}${hostName}/${uuid}?b64</a><br>
            <div id="qrcode_1" style="margin: 10px 10px 10px 10px;"></div>
            clashè®¢é˜…åœ°å€:<br>
            <a href="javascript:void(0)" onclick="copyToClipboard('https://${proxyhost}${hostName}/${uuid}?clash','qrcode_2')" style="color:blue;text-decoration:underline;cursor:pointer;">https://${proxyhost}${hostName}/${uuid}?clash</a><br>
            <div id="qrcode_2" style="margin: 10px 10px 10px 10px;"></div>
            singboxè®¢é˜…åœ°å€:<br>
            <a href="javascript:void(0)" onclick="copyToClipboard('https://${proxyhost}${hostName}/${uuid}?sb','qrcode_3')" style="color:blue;text-decoration:underline;cursor:pointer;">https://${proxyhost}${hostName}/${uuid}?sb</a><br>
            <div id="qrcode_3" style="margin: 10px 10px 10px 10px;"></div>
            loonè®¢é˜…åœ°å€:<br>
            <a href="javascript:void(0)" onclick="copyToClipboard('https://${proxyhost}${hostName}/${uuid}?loon','qrcode_5')" style="color:blue;text-decoration:underline;cursor:pointer;">https://${proxyhost}${hostName}/${uuid}?loon</a><br>
            <div id="qrcode_5" style="margin: 10px 10px 10px 10px;"></div>
            <strong><a href="javascript:void(0);" id="noticeToggle" onclick="toggleNotice()">å®ç”¨è®¢é˜…æŠ€å·§âˆ¨</a></strong><br>
                <div id="noticeContent" class="notice-content" style="display: none;">
                    <strong>1.</strong> å¦‚æ‚¨ä½¿ç”¨çš„æ˜¯ PassWallã€PassWall2 è·¯ç”±æ’ä»¶ï¼Œè®¢é˜…ç¼–è¾‘çš„ <strong>ç”¨æˆ·ä»£ç†(User-Agent)</strong> è®¾ç½®ä¸º <strong>PassWall</strong> å³å¯ï¼›<br>
                    <br>
                    <strong>2.</strong> å¦‚æ‚¨ä½¿ç”¨çš„æ˜¯ SSR+ è·¯ç”±æ’ä»¶ï¼Œæ¨èä½¿ç”¨ <strong>Base64è®¢é˜…åœ°å€</strong> è¿›è¡Œè®¢é˜…ï¼›<br>
                    <br>
                    <strong>3.</strong> å¿«é€Ÿåˆ‡æ¢ <a href='${atob('aHR0cHM6Ly9naXRodWIuY29tL2NtbGl1L1dvcmtlclZsZXNzMnN1Yg==')}'>ä¼˜é€‰è®¢é˜…ç”Ÿæˆå™¨</a> è‡³ï¼šsub.google.comï¼Œæ‚¨å¯å°†"?sub=sub.google.com"å‚æ•°æ·»åŠ åˆ°é“¾æ¥æœ«å°¾ï¼Œä¾‹å¦‚ï¼š<br>
                    &nbsp;&nbsp;https://${proxyhost}${hostName}/${uuid}<strong>?sub=sub.google.com</strong><br>
                    <br>
                    <strong>4.</strong> å¿«é€Ÿæ›´æ¢ PROXYIP è‡³ï¼šproxyip.cmliussss.net:443ï¼Œæ‚¨å¯å°†"?proxyip=proxyip.cmliussss.net:443"å‚æ•°æ·»åŠ åˆ°é“¾æ¥æœ«å°¾ï¼Œä¾‹å¦‚ï¼š<br>
                    &nbsp;&nbsp; https://${proxyhost}${hostName}/${uuid}<strong>?proxyip=proxyip.cmliussss.net:443</strong><br>
                    <br>
                    <strong>5.</strong> å¿«é€Ÿæ›´æ¢ SOCKS5 è‡³ï¼šuser:password@127.0.0.1:1080ï¼Œæ‚¨å¯å°†"?socks5=user:password@127.0.0.1:1080"å‚æ•°æ·»åŠ åˆ°é“¾æ¥æœ«å°¾ï¼Œä¾‹å¦‚ï¼š<br>
                    &nbsp;&nbsp;https://${proxyhost}${hostName}/${uuid}<strong>?socks5=user:password@127.0.0.1:1080</strong><br>
                    <br>
                    <strong>6.</strong> å¦‚éœ€æŒ‡å®šå¤šä¸ªå‚æ•°åˆ™éœ€è¦ä½¿ç”¨'&'åšé—´éš”ï¼Œä¾‹å¦‚ï¼š<br>
                    &nbsp;&nbsp;https://${proxyhost}${hostName}/${uuid}?sub=sub.google.com<strong>&</strong>proxyip=proxyip.cmliussss.net<br>
                </div>
            <script src="https://cdn.jsdelivr.net/npm/@keeex/qrcodejs-kx@1.0.2/qrcode.min.js"></script>
            <script>
            function copyToClipboard(text, qrcode) {
                navigator.clipboard.writeText(text).then(() => {
                    alert('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
                }).catch(err => {
                    console.error('å¤åˆ¶å¤±è´¥:', err);
                });
                const qrcodeDiv = document.getElementById(qrcode);
                qrcodeDiv.innerHTML = '';
                new QRCode(qrcodeDiv, {
                    text: text,
                    width: 220, // è°ƒæ•´å®½åº¦
                    height: 220, // è°ƒæ•´é«˜åº¦
                    colorDark: "#000000", // äºŒç»´ç é¢œè‰²
                    colorLight: "#ffffff", // èƒŒæ™¯é¢œè‰²
                    correctLevel: QRCode.CorrectLevel.Q, // è®¾ç½®çº é”™çº§åˆ«
                    scale: 1 // è°ƒæ•´åƒç´ é¢—ç²’åº¦
                });
            }

            function toggleNotice() {
                const noticeContent = document.getElementById('noticeContent');
                const noticeToggle = document.getElementById('noticeToggle');
                if (noticeContent.style.display === 'none') {
                    noticeContent.style.display = 'block';
                    noticeToggle.textContent = 'å®ç”¨è®¢é˜…æŠ€å·§âˆ§';
                } else {
                    noticeContent.style.display = 'none'; 
                    noticeToggle.textContent = 'å®ç”¨è®¢é˜…æŠ€å·§âˆ¨';
                }
            }
            </script>
            ---------------------------------------------------------------<br>
            ################################################################<br>
            ${FileName} é…ç½®ä¿¡æ¯<br>
            ---------------------------------------------------------------<br>
            ${åŠ¨æ€UUIDä¿¡æ¯}HOST: ${hostName}<br>
            UUID: ${userID}<br>
            FKID: ${fakeUserID}<br>
            UA: ${UA}<br>
            SCVï¼ˆè·³è¿‡TLSè¯ä¹¦éªŒè¯ï¼‰: ${SCV}<br>
            ${è®¢é˜…å™¨}<br>
            ---------------------------------------------------------------<br>
            ################################################################<br>
            v2ray<br>
            ---------------------------------------------------------------<br>
            <a href="javascript:void(0)" onclick="copyToClipboard('${v2ray}','qrcode_v2ray')" style="color:blue;text-decoration:underline;cursor:pointer;">${v2ray}</a><br>
            <div id="qrcode_v2ray" style="margin: 10px 10px 10px 10px;"></div>
            ---------------------------------------------------------------<br>
            ################################################################<br>
            clash-meta<br>
            ---------------------------------------------------------------<br>
            ${clash}<br>
            ---------------------------------------------------------------<br>
            ################################################################<br>
            ${cmad}
            `;
        return `<div style="font-size:13px;">${èŠ‚ç‚¹é…ç½®é¡µ}</div>`;
    } else {
        if (typeof fetch != 'function') {
            return 'Error: fetch is not available in this environment.';
        }

        let newAddressesapi = [];
        let newAddressescsv = [];
        let newAddressesnotlsapi = [];
        let newAddressesnotlscsv = [];

        // å¦‚æœæ˜¯ä½¿ç”¨é»˜è®¤åŸŸåï¼Œåˆ™æ”¹æˆä¸€ä¸ªworkersçš„åŸŸåï¼Œè®¢é˜…å™¨ä¼šåŠ ä¸Šä»£ç†
        if (hostName.includes(".workers.dev")) {
            noTLS = 'true';
            fakeHostName = `${fakeHostName}.workers.dev`;
            newAddressesnotlsapi = await æ•´ç†ä¼˜é€‰åˆ—è¡¨(addressesnotlsapi);
            newAddressesnotlscsv = await æ•´ç†æµ‹é€Ÿç»“æœ('FALSE');
        } else if (hostName.includes(".pages.dev")) {
            fakeHostName = `${fakeHostName}.pages.dev`;
        } else if (hostName.includes("worker") || hostName.includes("notls") || noTLS == 'true') {
            noTLS = 'true';
            fakeHostName = `notls${fakeHostName}.net`;
            newAddressesnotlsapi = await æ•´ç†ä¼˜é€‰åˆ—è¡¨(addressesnotlsapi);
            newAddressesnotlscsv = await æ•´ç†æµ‹é€Ÿç»“æœ('FALSE');
        } else {
            fakeHostName = `${fakeHostName}.xyz`
        }
        console.log(`è™šå‡HOST: ${fakeHostName}`);
        let url = `${subProtocol}://${sub}/sub?host=${fakeHostName}&uuid=${fakeUserID + atob('JmVkZ2V0dW5uZWw9Y21saXUmcHJveHlpcD0=') + RproxyIP}&path=${encodeURIComponent(path)}`;
        let isBase64 = true;

        if (!sub || sub == "") {
            if (hostName.includes('workers.dev')) {
                if (proxyhostsURL && (!proxyhosts || proxyhosts.length == 0)) {
                    try {
                        const response = await fetch(proxyhostsURL);

                        if (!response.ok) {
                            console.error('è·å–åœ°å€æ—¶å‡ºé”™:', response.status, response.statusText);
                            return; // å¦‚æœæœ‰é”™è¯¯ï¼Œç›´æ¥è¿”å›
                        }

                        const text = await response.text();
                        const lines = text.split('\n');
                        // è¿‡æ»¤æ‰ç©ºè¡Œæˆ–åªåŒ…å«ç©ºç™½å­—ç¬¦çš„è¡Œ
                        const nonEmptyLines = lines.filter(line => line.trim() !== '');

                        proxyhosts = proxyhosts.concat(nonEmptyLines);
                    } catch (error) {
                        console.error('è·å–åœ°å€æ—¶å‡ºé”™:', error);
                    }
                }
                // ä½¿ç”¨Setå¯¹è±¡å»é‡
                proxyhosts = [...new Set(proxyhosts)];
            }

            newAddressesapi = await æ•´ç†ä¼˜é€‰åˆ—è¡¨(addressesapi);
            newAddressescsv = await æ•´ç†æµ‹é€Ÿç»“æœ('TRUE');
            url = `https://${hostName}/${fakeUserID + _url.search}`;
            if (hostName.includes("worker") || hostName.includes("notls") || noTLS == 'true') {
                if (_url.search) url += '&notls';
                else url += '?notls';
            }
            console.log(`è™šå‡è®¢é˜…: ${url}`);
        }

        if (!userAgent.includes(('CF-Workers-SUB').toLowerCase()) && !_url.searchParams.has('b64') && !_url.searchParams.has('base64')) {
            if ((userAgent.includes('clash') && !userAgent.includes('nekobox')) || (_url.searchParams.has('clash') && !userAgent.includes('subconverter'))) {
                url = `${subProtocol}://${subConverter}/sub?target=clash&url=${encodeURIComponent(url)}&insert=false&config=${encodeURIComponent(subConfig)}&emoji=${subEmoji}&list=false&tfo=false&scv=${SCV}&fdn=false&sort=false&new_name=true`;
                isBase64 = false;
            } else if (userAgent.includes('sing-box') || userAgent.includes('singbox') || ((_url.searchParams.has('singbox') || _url.searchParams.has('sb')) && !userAgent.includes('subconverter'))) {
                url = `${subProtocol}://${subConverter}/sub?target=singbox&url=${encodeURIComponent(url)}&insert=false&config=${encodeURIComponent(subConfig)}&emoji=${subEmoji}&list=false&tfo=false&scv=${SCV}&fdn=false&sort=false&new_name=true`;
                isBase64 = false;
            } else if (userAgent.includes('loon') || (_url.searchParams.has('loon') && !userAgent.includes('subconverter'))) {
                url = `${subProtocol}://${subConverter}/sub?target=loon&url=${encodeURIComponent(url)}&insert=false&config=${encodeURIComponent(subConfig)}&emoji=${subEmoji}&list=false&tfo=false&scv=${SCV}&fdn=false&sort=false&new_name=true`;
                isBase64 = false;
            }
        }

        try {
            let content;
            if ((!sub || sub == "") && isBase64 == true) {
                content = await ç”Ÿæˆæœ¬åœ°è®¢é˜…(fakeHostName, fakeUserID, noTLS, newAddressesapi, newAddressescsv, newAddressesnotlsapi, newAddressesnotlscsv);
            } else {
                const response = await fetch(url, {
                    headers: {
                        'User-Agent': (isBase64 ? 'v2rayN' : UA) + atob('IENGLVdvcmtlcnMtZWRnZXR1bm5lbC9jbWxpdQ==')
                    }
                });
                content = await response.text();
            }

            if (_url.pathname == `/${fakeUserID}`) return content;

            return æ¢å¤ä¼ªè£…ä¿¡æ¯(content, userID, hostName, fakeUserID, fakeHostName, isBase64);

        } catch (error) {
            console.error('Error fetching content:', error);
            return `Error fetching content: ${error.message}`;
        }
    }
}

async function æ•´ç†ä¼˜é€‰åˆ—è¡¨(api) {
    if (!api || api.length === 0) return [];

    let newapi = "";

    // åˆ›å»ºä¸€ä¸ªAbortControllerå¯¹è±¡ï¼Œç”¨äºæ§åˆ¶fetchè¯·æ±‚çš„å–æ¶ˆ
    const controller = new AbortController();

    const timeout = setTimeout(() => {
        controller.abort(); // å–æ¶ˆæ‰€æœ‰è¯·æ±‚
    }, 2000); // 2ç§’åè§¦å‘

    try {
        // ä½¿ç”¨Promise.allSettledç­‰å¾…æ‰€æœ‰APIè¯·æ±‚å®Œæˆï¼Œæ— è®ºæˆåŠŸæˆ–å¤±è´¥
        // å¯¹apiæ•°ç»„è¿›è¡Œéå†ï¼Œå¯¹æ¯ä¸ªAPIåœ°å€å‘èµ·fetchè¯·æ±‚
        const responses = await Promise.allSettled(api.map(apiUrl => fetch(apiUrl, {
            method: 'get',
            headers: {
                'Accept': 'text/html,application/xhtml+xml,application/xml;',
                'User-Agent': atob('Q0YtV29ya2Vycy1lZGdldHVubmVsL2NtbGl1')
            },
            signal: controller.signal // å°†AbortControllerçš„ä¿¡å·é‡æ·»åŠ åˆ°fetchè¯·æ±‚ä¸­ï¼Œä»¥ä¾¿äºéœ€è¦æ—¶å¯ä»¥å–æ¶ˆè¯·æ±‚
        }).then(response => response.ok ? response.text() : Promise.reject())));

        // éå†æ‰€æœ‰å“åº”
        for (const [index, response] of responses.entries()) {
            // æ£€æŸ¥å“åº”çŠ¶æ€æ˜¯å¦ä¸º'fulfilled'ï¼Œå³è¯·æ±‚æˆåŠŸå®Œæˆ
            if (response.status === 'fulfilled') {
                // è·å–å“åº”çš„å†…å®¹
                const content = await response.value;

                const lines = content.split(/\r?\n/);
                let èŠ‚ç‚¹å¤‡æ³¨ = '';
                let æµ‹é€Ÿç«¯å£ = '443';

                if (lines[0].split(',').length > 3) {
                    const idMatch = api[index].match(/id=([^&]*)/);
                    if (idMatch) èŠ‚ç‚¹å¤‡æ³¨ = idMatch[1];

                    const portMatch = api[index].match(/port=([^&]*)/);
                    if (portMatch) æµ‹é€Ÿç«¯å£ = portMatch[1];

                    for (let i = 1; i < lines.length; i++) {
                        const columns = lines[i].split(',')[0];
                        if (columns) {
                            newapi += `${columns}:${æµ‹é€Ÿç«¯å£}${èŠ‚ç‚¹å¤‡æ³¨ ? `#${èŠ‚ç‚¹å¤‡æ³¨}` : ''}\n`;
                            if (api[index].includes('proxyip=true')) proxyIPPool.push(`${columns}:${æµ‹é€Ÿç«¯å£}`);
                        }
                    }
                } else {
                    // éªŒè¯å½“å‰apiUrlæ˜¯å¦å¸¦æœ‰'proxyip=true'
                    if (api[index].includes('proxyip=true')) {
                        // å¦‚æœURLå¸¦æœ‰'proxyip=true'ï¼Œåˆ™å°†å†…å®¹æ·»åŠ åˆ°proxyIPPool
                        proxyIPPool = proxyIPPool.concat((await æ•´ç†(content)).map(item => {
                            const baseItem = item.split('#')[0] || item;
                            if (baseItem.includes(':')) {
                                const port = baseItem.split(':')[1];
                                if (!httpsPorts.includes(port)) {
                                    return baseItem;
                                }
                            } else {
                                return `${baseItem}:443`;
                            }
                            return null; // ä¸ç¬¦åˆæ¡ä»¶æ—¶è¿”å› null
                        }).filter(Boolean)); // è¿‡æ»¤æ‰ null å€¼
                    }
                    // å°†å†…å®¹æ·»åŠ åˆ°newapiä¸­
                    newapi += content + '\n';
                }
            }
        }
    } catch (error) {
        console.error(error);
    } finally {
        // æ— è®ºæˆåŠŸæˆ–å¤±è´¥ï¼Œæœ€åéƒ½æ¸…é™¤è®¾ç½®çš„è¶…æ—¶å®šæ—¶å™¨
        clearTimeout(timeout);
    }

    const newAddressesapi = await æ•´ç†(newapi);

    // è¿”å›å¤„ç†åçš„ç»“æœ
    return newAddressesapi;
}

async function æ•´ç†æµ‹é€Ÿç»“æœ(tls) {
    if (!addressescsv || addressescsv.length === 0) {
        return [];
    }

    let newAddressescsv = [];

    for (const csvUrl of addressescsv) {
        try {
            const response = await fetch(csvUrl);

            if (!response.ok) {
                console.error('è·å–CSVåœ°å€æ—¶å‡ºé”™:', response.status, response.statusText);
                continue;
            }

            const text = await response.text();// ä½¿ç”¨æ­£ç¡®çš„å­—ç¬¦ç¼–ç è§£ææ–‡æœ¬å†…å®¹
            let lines;
            if (text.includes('\r\n')) {
                lines = text.split('\r\n');
            } else {
                lines = text.split('\n');
            }

            // æ£€æŸ¥CSVå¤´éƒ¨æ˜¯å¦åŒ…å«å¿…éœ€å­—æ®µ
            const header = lines[0].split(',');
            const tlsIndex = header.indexOf('TLS');

            const ipAddressIndex = 0;// IPåœ°å€åœ¨ CSV å¤´éƒ¨çš„ä½ç½®
            const portIndex = 1;// ç«¯å£åœ¨ CSV å¤´éƒ¨çš„ä½ç½®
            const dataCenterIndex = tlsIndex + remarkIndex; // æ•°æ®ä¸­å¿ƒæ˜¯ TLS çš„åä¸€ä¸ªå­—æ®µ

            if (tlsIndex === -1) {
                console.error('CSVæ–‡ä»¶ç¼ºå°‘å¿…éœ€çš„å­—æ®µ');
                continue;
            }

            // ä»ç¬¬äºŒè¡Œå¼€å§‹éå†CSVè¡Œ
            for (let i = 1; i < lines.length; i++) {
                const columns = lines[i].split(',');
                const speedIndex = columns.length - 1; // æœ€åä¸€ä¸ªå­—æ®µ
                // æ£€æŸ¥TLSæ˜¯å¦ä¸º"TRUE"ä¸”é€Ÿåº¦å¤§äºDLS
                if (columns[tlsIndex].toUpperCase() === tls && parseFloat(columns[speedIndex]) > DLS) {
                    const ipAddress = columns[ipAddressIndex];
                    const port = columns[portIndex];
                    const dataCenter = columns[dataCenterIndex];

                    const formattedAddress = `${ipAddress}:${port}#${dataCenter}`;
                    newAddressescsv.push(formattedAddress);
                    if (csvUrl.includes('proxyip=true') && columns[tlsIndex].toUpperCase() == 'true' && !httpsPorts.includes(port)) {
                        // å¦‚æœURLå¸¦æœ‰'proxyip=true'ï¼Œåˆ™å°†å†…å®¹æ·»åŠ åˆ°proxyIPPool
                        proxyIPPool.push(`${ipAddress}:${port}`);
                    }
                }
            }
        } catch (error) {
            console.error('è·å–CSVåœ°å€æ—¶å‡ºé”™:', error);
            continue;
        }
    }

    return newAddressescsv;
}

function ç”Ÿæˆæœ¬åœ°è®¢é˜…(host, UUID, noTLS, newAddressesapi, newAddressescsv, newAddressesnotlsapi, newAddressesnotlscsv) {
    const regex = /^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}|\[.*\]):?(\d+)?#?(.*)?$/;
    addresses = addresses.concat(newAddressesapi);
    addresses = addresses.concat(newAddressescsv);
    let notlsresponseBody;
    if (noTLS == 'true') {
        addressesnotls = addressesnotls.concat(newAddressesnotlsapi);
        addressesnotls = addressesnotls.concat(newAddressesnotlscsv);
        const uniqueAddressesnotls = [...new Set(addressesnotls)];

        notlsresponseBody = uniqueAddressesnotls.map(address => {
            let port = "-1";
            let addressid = address;

            const match = addressid.match(regex);
            if (!match) {
                if (address.includes(':') && address.includes('#')) {
                    const parts = address.split(':');
                    address = parts[0];
                    const subParts = parts[1].split('#');
                    port = subParts[0];
                    addressid = subParts[1];
                } else if (address.includes(':')) {
                    const parts = address.split(':');
                    address = parts[0];
                    port = parts[1];
                } else if (address.includes('#')) {
                    const parts = address.split('#');
                    address = parts[0];
                    addressid = parts[1];
                }

                if (addressid.includes(':')) {
                    addressid = addressid.split(':')[0];
                }
            } else {
                address = match[1];
                port = match[2] || port;
                addressid = match[3] || address;
            }

            if (!isValidIPv4(address) && port == "-1") {
                for (let httpPort of httpPorts) {
                    if (address.includes(httpPort)) {
                        port = httpPort;
                        break;
                    }
                }
            }
            if (port == "-1") port = "80";

            let ä¼ªè£…åŸŸå = host;
            let æœ€ç»ˆè·¯å¾„ = path;
            let èŠ‚ç‚¹å¤‡æ³¨ = '';
            const åè®®ç±»å‹ = atob(å•¥å•¥å•¥_å†™çš„è¿™æ˜¯å•¥å•Š);

            const ç»´åˆ—æ–¯Link = `${åè®®ç±»å‹}://${UUID}@${address}:${port + atob('P2VuY3J5cHRpb249bm9uZSZzZWN1cml0eT0mdHlwZT13cyZob3N0PQ==') + ä¼ªè£…åŸŸå}&path=${encodeURIComponent(æœ€ç»ˆè·¯å¾„)}#${encodeURIComponent(addressid + èŠ‚ç‚¹å¤‡æ³¨)}`;

            return ç»´åˆ—æ–¯Link;

        }).join('\n');

    }

    // ä½¿ç”¨Setå¯¹è±¡å»é‡
    const uniqueAddresses = [...new Set(addresses)];

    const responseBody = uniqueAddresses.map(address => {
        let port = "-1";
        let addressid = address;

        const match = addressid.match(regex);
        if (!match) {
            if (address.includes(':') && address.includes('#')) {
                const parts = address.split(':');
                address = parts[0];
                const subParts = parts[1].split('#');
                port = subParts[0];
                addressid = subParts[1];
            } else if (address.includes(':')) {
                const parts = address.split(':');
                address = parts[0];
                port = parts[1];
            } else if (address.includes('#')) {
                const parts = address.split('#');
                address = parts[0];
                addressid = parts[1];
            }

            if (addressid.includes(':')) {
                addressid = addressid.split(':')[0];
            }
        } else {
            address = match[1];
            port = match[2] || port;
            addressid = match[3] || address;
        }

        if (!isValidIPv4(address) && port == "-1") {
            for (let httpsPort of httpsPorts) {
                if (address.includes(httpsPort)) {
                    port = httpsPort;
                    break;
                }
            }
        }
        if (port == "-1") port = "443";

        let ä¼ªè£…åŸŸå = host;
        let æœ€ç»ˆè·¯å¾„ = path;
        let èŠ‚ç‚¹å¤‡æ³¨ = '';
        const matchingProxyIP = proxyIPPool.find(proxyIP => proxyIP.includes(address));
        if (matchingProxyIP) æœ€ç»ˆè·¯å¾„ = `/proxyip=${matchingProxyIP}`;
        /*
        if (proxyhosts.length > 0 && (ä¼ªè£…åŸŸå.includes('.workers.dev'))) {
            æœ€ç»ˆè·¯å¾„ = `/${ä¼ªè£…åŸŸå}${æœ€ç»ˆè·¯å¾„}`;
            ä¼ªè£…åŸŸå = proxyhosts[Math.floor(Math.random() * proxyhosts.length)];
            èŠ‚ç‚¹å¤‡æ³¨ = ` å·²å¯ç”¨ä¸´æ—¶åŸŸåä¸­è½¬æœåŠ¡ï¼Œè¯·å°½å¿«ç»‘å®šè‡ªå®šä¹‰åŸŸï¼`;
        }
        */
        const åè®®ç±»å‹ = atob(å•¥å•¥å•¥_å†™çš„è¿™æ˜¯å•¥å•Š);
        const ç»´åˆ—æ–¯Link = `${åè®®ç±»å‹}://${UUID}@${address}:${port + atob('P2VuY3J5cHRpb249bm9uZSZzZWN1cml0eT10bHMmc25pPQ==') + ä¼ªè£…åŸŸå}&fp=random&type=ws&host=${ä¼ªè£…åŸŸå}&path=${encodeURIComponent(æœ€ç»ˆè·¯å¾„) + allowInsecure}&fragment=${encodeURIComponent('1,40-60,30-50,tlshello')}#${encodeURIComponent(addressid + èŠ‚ç‚¹å¤‡æ³¨)}`;

        return ç»´åˆ—æ–¯Link;
    }).join('\n');

    let base64Response = responseBody; // é‡æ–°è¿›è¡Œ Base64 ç¼–ç 
    if (noTLS == 'true') base64Response += `\n${notlsresponseBody}`;
    if (link.length > 0) base64Response += '\n' + link.join('\n');
    return btoa(base64Response);
}

async function æ•´ç†(å†…å®¹) {
    // å°†åˆ¶è¡¨ç¬¦ã€åŒå¼•å·ã€å•å¼•å·å’Œæ¢è¡Œç¬¦éƒ½æ›¿æ¢ä¸ºé€—å·
    // ç„¶åå°†è¿ç»­çš„å¤šä¸ªé€—å·æ›¿æ¢ä¸ºå•ä¸ªé€—å·
    var æ›¿æ¢åçš„å†…å®¹ = å†…å®¹.replace(/[	"'\r\n]+/g, ',').replace(/,+/g, ',');

    // åˆ é™¤å¼€å¤´å’Œç»“å°¾çš„é€—å·ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
    if (æ›¿æ¢åçš„å†…å®¹.charAt(0) == ',') æ›¿æ¢åçš„å†…å®¹ = æ›¿æ¢åçš„å†…å®¹.slice(1);
    if (æ›¿æ¢åçš„å†…å®¹.charAt(æ›¿æ¢åçš„å†…å®¹.length - 1) == ',') æ›¿æ¢åçš„å†…å®¹ = æ›¿æ¢åçš„å†…å®¹.slice(0, æ›¿æ¢åçš„å†…å®¹.length - 1);

    // ä½¿ç”¨é€—å·åˆ†å‰²å­—ç¬¦ä¸²ï¼Œå¾—åˆ°åœ°å€æ•°ç»„
    const åœ°å€æ•°ç»„ = æ›¿æ¢åçš„å†…å®¹.split(',');

    return åœ°å€æ•°ç»„;
}

async function sendMessage(type, ip, add_data = "") {
    if (!BotToken || !ChatID) return;

    try {
        let msg = "";
        const response = await fetch(`http://ip-api.com/json/${ip}?lang=zh-CN`);
        if (response.ok) {
            const ipInfo = await response.json();
            msg = `${type}\nIP: ${ip}\nå›½å®¶: ${ipInfo.country}\n<tg-spoiler>åŸå¸‚: ${ipInfo.city}\nç»„ç»‡: ${ipInfo.org}\nASN: ${ipInfo.as}\n${add_data}`;
        } else {
            msg = `${type}\nIP: ${ip}\n<tg-spoiler>${add_data}`;
        }

        const url = `https://api.telegram.org/bot${BotToken}/sendMessage?chat_id=${ChatID}&parse_mode=HTML&text=${encodeURIComponent(msg)}`;
        return fetch(url, {
            method: 'GET',
            headers: {
                'Accept': 'text/html,application/xhtml+xml,application/xml;',
                'Accept-Encoding': 'gzip, deflate, br',
                'User-Agent': 'Mozilla/5.0 Chrome/90.0.4430.72'
            }
        });
    } catch (error) {
        console.error('Error sending message:', error);
    }
}

function isValidIPv4(address) {
    const ipv4Regex = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
    return ipv4Regex.test(address);
}

function ç”ŸæˆåŠ¨æ€UUID(å¯†é’¥) {
    const æ—¶åŒºåç§» = 8; // åŒ—äº¬æ—¶é—´ç›¸å¯¹äºUTCçš„æ—¶åŒºåç§»+8å°æ—¶
    const èµ·å§‹æ—¥æœŸ = new Date(2007, 6, 7, æ›´æ–°æ—¶é—´, 0, 0); // å›ºå®šèµ·å§‹æ—¥æœŸä¸º2007å¹´7æœˆ7æ—¥çš„å‡Œæ™¨3ç‚¹
    const ä¸€å‘¨çš„æ¯«ç§’æ•° = 1000 * 60 * 60 * 24 * æœ‰æ•ˆæ—¶é—´;

    function è·å–å½“å‰å‘¨æ•°() {
        const ç°åœ¨ = new Date();
        const è°ƒæ•´åçš„ç°åœ¨ = new Date(ç°åœ¨.getTime() + æ—¶åŒºåç§» * 60 * 60 * 1000);
        const æ—¶é—´å·® = Number(è°ƒæ•´åçš„ç°åœ¨) - Number(èµ·å§‹æ—¥æœŸ);
        return Math.ceil(æ—¶é—´å·® / ä¸€å‘¨çš„æ¯«ç§’æ•°);
    }

    function ç”ŸæˆUUID(åŸºç¡€å­—ç¬¦ä¸²) {
        const å“ˆå¸Œç¼“å†²åŒº = new TextEncoder().encode(åŸºç¡€å­—ç¬¦ä¸²);
        return crypto.subtle.digest('SHA-256', å“ˆå¸Œç¼“å†²åŒº).then((å“ˆå¸Œ) => {
            const å“ˆå¸Œæ•°ç»„ = Array.from(new Uint8Array(å“ˆå¸Œ));
            const åå…­è¿›åˆ¶å“ˆå¸Œ = å“ˆå¸Œæ•°ç»„.map(b => b.toString(16).padStart(2, '0')).join('');
            return `${åå…­è¿›åˆ¶å“ˆå¸Œ.substr(0, 8)}-${åå…­è¿›åˆ¶å“ˆå¸Œ.substr(8, 4)}-4${åå…­è¿›åˆ¶å“ˆå¸Œ.substr(13, 3)}-${(parseInt(åå…­è¿›åˆ¶å“ˆå¸Œ.substr(16, 2), 16) & 0x3f | 0x80).toString(16)}${åå…­è¿›åˆ¶å“ˆå¸Œ.substr(18, 2)}-${åå…­è¿›åˆ¶å“ˆå¸Œ.substr(20, 12)}`;
        });
    }

    const å½“å‰å‘¨æ•° = è·å–å½“å‰å‘¨æ•°(); // è·å–å½“å‰å‘¨æ•°
    const ç»“æŸæ—¶é—´ = new Date(èµ·å§‹æ—¥æœŸ.getTime() + å½“å‰å‘¨æ•° * ä¸€å‘¨çš„æ¯«ç§’æ•°);

    // ç”Ÿæˆä¸¤ä¸ª UUID
    const å½“å‰UUIDPromise = ç”ŸæˆUUID(å¯†é’¥ + å½“å‰å‘¨æ•°);
    const ä¸Šä¸€ä¸ªUUIDPromise = ç”ŸæˆUUID(å¯†é’¥ + (å½“å‰å‘¨æ•° - 1));

    // æ ¼å¼åŒ–åˆ°æœŸæ—¶é—´
    const åˆ°æœŸæ—¶é—´UTC = new Date(ç»“æŸæ—¶é—´.getTime() - æ—¶åŒºåç§» * 60 * 60 * 1000); // UTCæ—¶é—´
    const åˆ°æœŸæ—¶é—´å­—ç¬¦ä¸² = `åˆ°æœŸæ—¶é—´(UTC): ${åˆ°æœŸæ—¶é—´UTC.toISOString().slice(0, 19).replace('T', ' ')} (UTC+8): ${ç»“æŸæ—¶é—´.toISOString().slice(0, 19).replace('T', ' ')}\n`;

    return Promise.all([å½“å‰UUIDPromise, ä¸Šä¸€ä¸ªUUIDPromise, åˆ°æœŸæ—¶é—´å­—ç¬¦ä¸²]);
}

async function è¿ç§»åœ°å€åˆ—è¡¨(env, txt = 'ADD.txt') {
    const æ—§æ•°æ® = await env.KV.get(`/${txt}`);
    const æ–°æ•°æ® = await env.KV.get(txt);

    if (æ—§æ•°æ® && !æ–°æ•°æ®) {
        // å†™å…¥æ–°ä½ç½®
        await env.KV.put(txt, æ—§æ•°æ®);
        // åˆ é™¤æ—§æ•°æ®
        await env.KV.delete(`/${txt}`);
        return true;
    }
    return false;
}

async function KV(request, env, txt = 'ADD.txt') {
    try {
        // POSTè¯·æ±‚å¤„ç†
        if (request.method === "POST") {
            if (!env.KV) return new Response("æœªç»‘å®šKVç©ºé—´", { status: 400 });
            try {
                const content = await request.text();
                await env.KV.put(txt, content);
                return new Response("ä¿å­˜æˆåŠŸ");
            } catch (error) {
                console.error('ä¿å­˜KVæ—¶å‘ç”Ÿé”™è¯¯:', error);
                return new Response("ä¿å­˜å¤±è´¥: " + error.message, { status: 500 });
            }
        }

        // GETè¯·æ±‚éƒ¨åˆ†
        let content = '';
        let hasKV = !!env.KV;

        if (hasKV) {
            try {
                content = await env.KV.get(txt) || '';
            } catch (error) {
                console.error('è¯»å–KVæ—¶å‘ç”Ÿé”™è¯¯:', error);
                content = 'è¯»å–æ•°æ®æ—¶å‘ç”Ÿé”™è¯¯: ' + error.message;
            }
        }

        const html = `
            <!DOCTYPE html>
            <html>
            <head>
                <title>ä¼˜é€‰è®¢é˜…åˆ—è¡¨</title>
                <meta charset="utf-8">
                <meta name="viewport" content="width=device-width, initial-scale=1">
                <style>
                    body {
                        margin: 0;
                        padding: 15px; /* è°ƒæ•´padding */
                        box-sizing: border-box;
                        font-size: 13px; /* è®¾ç½®å…¨å±€å­—ä½“å¤§å° */
                    }
                    .editor-container {
                        width: 100%;
                        max-width: 100%;
                        margin: 0 auto;
                    }
                    .editor {
                        width: 100%;
                        height: 520px; /* è°ƒæ•´é«˜åº¦ */
                        margin: 15px 0; /* è°ƒæ•´margin */
                        padding: 10px; /* è°ƒæ•´padding */
                        box-sizing: border-box;
                        border: 1px solid #ccc;
                        border-radius: 4px;
                        font-size: 13px;
                        line-height: 1.5;
                        overflow-y: auto;
                        resize: none;
                    }
                    .save-container {
                        margin-top: 8px; /* è°ƒæ•´margin */
                        display: flex;
                        align-items: center;
                        gap: 10px; /* è°ƒæ•´gap */
                    }
                    .save-btn, .back-btn {
                        padding: 6px 15px; /* è°ƒæ•´padding */
                        color: white;
                        border: none;
                        border-radius: 4px;
                        cursor: pointer;
                    }
                    .save-btn {
                        background: #4CAF50;
                    }
                    .save-btn:hover {
                        background: #45a049;
                    }
                    .back-btn {
                        background: #666;
                    }
                    .back-btn:hover {
                        background: #555;
                    }
                    .bestip-btn {
                        background: #2196F3;
                        padding: 6px 15px;
                        color: white;
                        border: none;
                        border-radius: 4px;
                        cursor: pointer;
                    }
                    .bestip-btn:hover {
                        background: #1976D2;
                    }
                    .save-status {
                        color: #666;
                    }
                    .notice-content {
                        display: none;
                        margin-top: 10px;
                        font-size: 13px;
                        color: #333;
                    }
                </style>
            </head>
            <body>
                ################################################################<br>
                ${FileName} ä¼˜é€‰è®¢é˜…åˆ—è¡¨:<br>
                ---------------------------------------------------------------<br>
                &nbsp;&nbsp;<strong><a href="javascript:void(0);" id="noticeToggle" onclick="toggleNotice()">æ³¨æ„äº‹é¡¹âˆ¨</a></strong><br>
                <div id="noticeContent" class="notice-content">
                    ${decodeURIComponent(atob('JTA5JTA5JTA5JTA5JTA5JTNDc3Ryb25nJTNFMS4lM0MlMkZzdHJvbmclM0UlMjBBRERBUEklMjAlRTUlQTYlODIlRTYlOUUlOUMlRTYlOTglQUYlRTUlOEYlOEQlRTQlQkIlQTNJUCVFRiVCQyU4QyVFNSU4RiVBRiVFNCVCRCU5QyVFNCVCOCVCQVBST1hZSVAlRTclOUElODQlRTglQUYlOUQlRUYlQkMlOEMlRTUlOEYlQUYlRTUlQjAlODYlMjIlM0Zwcm94eWlwJTNEdHJ1ZSUyMiVFNSU4RiU4MiVFNiU5NSVCMCVFNiVCNyVCQiVFNSU4QSVBMCVFNSU4OCVCMCVFOSU5MyVCRSVFNiU4RSVBNSVFNiU5QyVBQiVFNSVCMCVCRSVFRiVCQyU4QyVFNCVCRSU4QiVFNSVBNiU4MiVFRiVCQyU5QSUzQ2JyJTNFCiUwOSUwOSUwOSUwOSUwOSUyNm5ic3AlM0IlMjZuYnNwJTNCaHR0cHMlM0ElMkYlMkZyYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tJTJGY21saXUlMkZXb3JrZXJWbGVzczJzdWIlMkZtYWluJTJGYWRkcmVzc2VzYXBpLnR4dCUzQ3N0cm9uZyUzRSUzRnByb3h5aXAlM0R0cnVlJTNDJTJGc3Ryb25nJTNFJTNDYnIlM0UlM0NiciUzRQolMDklMDklMDklMDklMDklM0NzdHJvbmclM0UyLiUzQyUyRnN0cm9uZyUzRSUyMEFEREFQSSUyMCVFNSVBNiU4MiVFNiU5RSU5QyVFNiU5OCVBRiUyMCUzQ2ElMjBocmVmJTNEJTI3aHR0cHMlM0ElMkYlMkZnaXRodWIuY29tJTJGWElVMiUyRkNsb3VkZmxhcmVTcGVlZFRlc3QlMjclM0VDbG91ZGZsYXJlU3BlZWRUZXN0JTNDJTJGYSUzRSUyMCVFNyU5QSU4NCUyMGNzdiUyMCVFNyVCQiU5MyVFNiU5RSU5QyVFNiU5NiU4NyVFNCVCQiVCNiVFRiVCQyU4QyVFNCVCRSU4QiVFNSVBNiU4MiVFRiVCQyU5QSUzQ2JyJTNFCiUwOSUwOSUwOSUwOSUwOSUyNm5ic3AlM0IlMjZuYnNwJTNCaHR0cHMlM0ElMkYlMkZyYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tJTJGY21saXUlMkZXb3JrZXJWbGVzczJzdWIlMkZtYWluJTJGQ2xvdWRmbGFyZVNwZWVkVGVzdC5jc3YlM0NiciUzRSUzQ2JyJTNFCiUwOSUwOSUwOSUwOSUwOSUyNm5ic3AlM0IlMjZuYnNwJTNCLSUyMCVFNSVBNiU4MiVFOSU5QyU4MCVFNiU4QyU4NyVFNSVBRSU5QTIwNTMlRTclQUIlQUYlRTUlOEYlQTMlRTUlOEYlQUYlRTUlQjAlODYlMjIlM0Zwb3J0JTNEMjA1MyUyMiVFNSU4RiU4MiVFNiU5NSVCMCVFNiVCNyVCQiVFNSU4QSVBMCVFNSU4OCVCMCVFOSU5MyVCRSVFNiU4RSVBNSVFNiU5QyVBQiVFNSVCMCVCRSVFRiVCQyU4QyVFNCVCRSU4QiVFNSVBNiU4MiVFRiVCQyU5QSUzQ2JyJTNFCiUwOSUwOSUwOSUwOSUwOSUyNm5ic3AlM0IlMjZuYnNwJTNCaHR0cHMlM0ElMkYlMkZyYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tJTJGY21saXUlMkZXb3JrZXJWbGVzczJzdWIlMkZtYWluJTJGQ2xvdWRmbGFyZVNwZWVkVGVzdC5jc3YlM0NzdHJvbmclM0UlM0Zwb3J0JTNEMjA1MyUzQyUyRnN0cm9uZyUzRSUzQ2JyJTNFJTNDYnIlM0UKJTA5JTA5JTA5JTA5JTA5JTI2bmJzcCUzQiUyNm5ic3AlM0ItJTIwJUU1JUE2JTgyJUU5JTlDJTgwJUU2JThDJTg3JUU1JUFFJTlBJUU4JThBJTgyJUU3JTgyJUI5JUU1JUE0JTg3JUU2JUIzJUE4JUU1JThGJUFGJUU1JUIwJTg2JTIyJTNGaWQlM0RDRiVFNCVCQyU5OCVFOSU4MCU4OSUyMiVFNSU4RiU4MiVFNiU5NSVCMCVFNiVCNyVCQiVFNSU4QSVBMCVFNSU4OCVCMCVFOSU5MyVCRSVFNiU4RSVBNSVFNiU5QyVBQiVFNSVCMCVCRSVFRiVCQyU4QyVFNCVCRSU4QiVFNSVBNiU4MiVFRiVCQyU5QSUzQ2JyJTNFCiUwOSUwOSUwOSUwOSUwOSUyNm5ic3AlM0IlMjZuYnNwJTNCaHR0cHMlM0ElMkYlMkZyYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tJTJGY21saXUlMkZXb3JrZXJWbGVzczJzdWIlMkZtYWluJTJGQ2xvdWRmbGFyZVNwZWVkVGVzdC5jc3YlM0NzdHJvbmclM0UlM0ZpZCUzRENGJUU0JUJDJTk4JUU5JTgwJTg5JTNDJTJGc3Ryb25nJTNFJTNDYnIlM0UlM0NiciUzRQolMDklMDklMDklMDklMDklMjZuYnNwJTNCJTI2bmJzcCUzQi0lMjAlRTUlQTYlODIlRTklOUMlODAlRTYlOEMlODclRTUlQUUlOUElRTUlQTQlOUElRTQlQjglQUElRTUlOEYlODIlRTYlOTUlQjAlRTUlODglOTklRTklOUMlODAlRTglQTYlODElRTQlQkQlQkYlRTclOTQlQTglMjclMjYlMjclRTUlODElOUElRTklOTclQjQlRTklOUElOTQlRUYlQkMlOEMlRTQlQkUlOEIlRTUlQTYlODIlRUYlQkMlOUElM0NiciUzRQolMDklMDklMDklMDklMDklMjZuYnNwJTNCJTI2bmJzcCUzQmh0dHBzJTNBJTJGJTJGcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSUyRmNtbGl1JTJGV29ya2VyVmxlc3Myc3ViJTJGbWFpbiUyRkNsb3VkZmxhcmVTcGVlZFRlc3QuY3N2JTNGaWQlM0RDRiVFNCVCQyU5OCVFOSU4MCU4OSUzQ3N0cm9uZyUzRSUyNiUzQyUyRnN0cm9uZyUzRXBvcnQlM0QyMDUzJTNDYnIlM0U='))}
                </div>
                <div class="editor-container">
                    ${hasKV ? `
                    <textarea class="editor" 
                        placeholder="${decodeURIComponent(atob('QUREJUU3JUE0JUJBJUU0JUJFJThCJUVGJUJDJTlBCnZpc2EuY24lMjMlRTQlQkMlOTglRTklODAlODklRTUlOUYlOUYlRTUlOTAlOEQKMTI3LjAuMC4xJTNBMTIzNCUyM0NGbmF0CiU1QjI2MDYlM0E0NzAwJTNBJTNBJTVEJTNBMjA1MyUyM0lQdjYKCiVFNiVCMyVBOCVFNiU4NCU4RiVFRiVCQyU5QQolRTYlQUYlOEYlRTglQTElOEMlRTQlQjglODAlRTQlQjglQUElRTUlOUMlQjAlRTUlOUQlODAlRUYlQkMlOEMlRTYlQTAlQkMlRTUlQkMlOEYlRTQlQjglQkElMjAlRTUlOUMlQjAlRTUlOUQlODAlM0ElRTclQUIlQUYlRTUlOEYlQTMlMjMlRTUlQTQlODclRTYlQjMlQTgKSVB2NiVFNSU5QyVCMCVFNSU5RCU4MCVFOSU5QyU4MCVFOCVBNiU4MSVFNyU5NCVBOCVFNCVCOCVBRCVFNiU4QiVBQyVFNSU4RiVCNyVFNiU4QiVBQyVFOCVCNSVCNyVFNiU5RCVBNSVFRiVCQyU4QyVFNSVBNiU4MiVFRiVCQyU5QSU1QjI2MDYlM0E0NzAwJTNBJTNBJTVEJTNBMjA1MwolRTclQUIlQUYlRTUlOEYlQTMlRTQlQjglOEQlRTUlODYlOTklRUYlQkMlOEMlRTklQkIlOTglRTglQUUlQTQlRTQlQjglQkElMjA0NDMlMjAlRTclQUIlQUYlRTUlOEYlQTMlRUYlQkMlOEMlRTUlQTYlODIlRUYlQkMlOUF2aXNhLmNuJTIzJUU0JUJDJTk4JUU5JTgwJTg5JUU1JTlGJTlGJUU1JTkwJThECgoKQUREQVBJJUU3JUE0JUJBJUU0JUJFJThCJUVGJUJDJTlBCmh0dHBzJTNBJTJGJTJGcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSUyRmNtbGl1JTJGV29ya2VyVmxlc3Myc3ViJTJGcmVmcyUyRmhlYWRzJTJGbWFpbiUyRmFkZHJlc3Nlc2FwaS50eHQKCiVFNiVCMyVBOCVFNiU4NCU4RiVFRiVCQyU5QUFEREFQSSVFNyU5QiVCNCVFNiU4RSVBNSVFNiVCNyVCQiVFNSU4QSVBMCVFNyU5QiVCNCVFOSU5MyVCRSVFNSU4RCVCMyVFNSU4RiVBRg=='))}"
                        id="content">${content}</textarea>
                    <div class="save-container">
                        <button class="back-btn" onclick="goBack()">è¿”å›é…ç½®é¡µ</button>
                        <button class="bestip-btn" onclick="goBestIP()">åœ¨çº¿ä¼˜é€‰IP</button>
                        <button class="save-btn" onclick="saveContent(this)">ä¿å­˜</button>
                        <span class="save-status" id="saveStatus"></span>
                    </div>
                    <br>
                    ################################################################<br>
                    ${cmad}
                    ` : '<p>æœªç»‘å®šKVç©ºé—´</p>'}
                </div>
        
                <script>
                if (document.querySelector('.editor')) {
                    let timer;
                    const textarea = document.getElementById('content');
                    const originalContent = textarea.value;
        
                    function goBack() {
                        const currentUrl = window.location.href;
                        const parentUrl = currentUrl.substring(0, currentUrl.lastIndexOf('/'));
                        window.location.href = parentUrl;
                    }
        
                    function goBestIP() {
                        const currentUrl = window.location.href;
                        const parentUrl = currentUrl.substring(0, currentUrl.lastIndexOf('/'));
                        window.location.href = parentUrl + '/bestip';
                    }
        
                    function replaceFullwidthColon() {
                        const text = textarea.value;
                        textarea.value = text.replace(/ï¼š/g, ':');
                    }
                    
                    function saveContent(button) {
                        try {
                            const updateButtonText = (step) => {
                                button.textContent = \`ä¿å­˜ä¸­: \${step}\`;
                            };
                            // æ£€æµ‹æ˜¯å¦ä¸ºiOSè®¾å¤‡
                            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                            
                            // ä»…åœ¨éiOSè®¾å¤‡ä¸Šæ‰§è¡ŒreplaceFullwidthColon
                            if (!isIOS) {
                                replaceFullwidthColon();
                            }
                            updateButtonText('å¼€å§‹ä¿å­˜');
                            button.disabled = true;
                            // è·å–textareaå†…å®¹å’ŒåŸå§‹å†…å®¹
                            const textarea = document.getElementById('content');
                            if (!textarea) {
                                throw new Error('æ‰¾ä¸åˆ°æ–‡æœ¬ç¼–è¾‘åŒºåŸŸ');
                            }
                            updateButtonText('è·å–å†…å®¹');
                            let newContent;
                            let originalContent;
                            try {
                                newContent = textarea.value || '';
                                originalContent = textarea.defaultValue || '';
                            } catch (e) {
                                console.error('è·å–å†…å®¹é”™è¯¯:', e);
                                throw new Error('æ— æ³•è·å–ç¼–è¾‘å†…å®¹');
                            }
                            updateButtonText('å‡†å¤‡çŠ¶æ€æ›´æ–°å‡½æ•°');
                            const updateStatus = (message, isError = false) => {
                                const statusElem = document.getElementById('saveStatus');
                                if (statusElem) {
                                    statusElem.textContent = message;
                                    statusElem.style.color = isError ? 'red' : '#666';
                                }
                            };
                            updateButtonText('å‡†å¤‡æŒ‰é’®é‡ç½®å‡½æ•°');
                            const resetButton = () => {
                                button.textContent = 'ä¿å­˜';
                                button.disabled = false;
                            };
                            if (newContent !== originalContent) {
                                updateButtonText('å‘é€ä¿å­˜è¯·æ±‚');
                                fetch(window.location.href, {
                                    method: 'POST',
                                    body: newContent,
                                    headers: {
                                        'Content-Type': 'text/plain;charset=UTF-8'
                                    },
                                    cache: 'no-cache'
                                })
                                .then(response => {
                                    updateButtonText('æ£€æŸ¥å“åº”çŠ¶æ€');
                                    if (!response.ok) {
                                        throw new Error(\`HTTP error! status: \${response.status}\`);
                                    }
                                    updateButtonText('æ›´æ–°ä¿å­˜çŠ¶æ€');
                                    const now = new Date().toLocaleString();
                                    document.title = \`ç¼–è¾‘å·²ä¿å­˜ \${now}\`;
                                    updateStatus(\`å·²ä¿å­˜ \${now}\`);
                                })
                                .catch(error => {
                                    updateButtonText('å¤„ç†é”™è¯¯');
                                    console.error('Save error:', error);
                                    updateStatus(\`ä¿å­˜å¤±è´¥: \${error.message}\`, true);
                                })
                                .finally(() => {
                                    resetButton();
                                });
                            } else {
                                updateButtonText('æ£€æŸ¥å†…å®¹å˜åŒ–');
                                updateStatus('å†…å®¹æœªå˜åŒ–');
                                resetButton();
                            }
                        } catch (error) {
                            console.error('ä¿å­˜è¿‡ç¨‹å‡ºé”™:', error);
                            button.textContent = 'ä¿å­˜';
                            button.disabled = false;
                            const statusElem = document.getElementById('saveStatus');
                            if (statusElem) {
                                statusElem.textContent = \`é”™è¯¯: \${error.message}\`;
                                statusElem.style.color = 'red';
                            }
                        }
                    }
        
                    textarea.addEventListener('blur', saveContent);
                    textarea.addEventListener('input', () => {
                        clearTimeout(timer);
                        timer = setTimeout(saveContent, 5000);
                    });
                }
        
                function toggleNotice() {
                    const noticeContent = document.getElementById('noticeContent');
                    const noticeToggle = document.getElementById('noticeToggle');
                    if (noticeContent.style.display === 'none' || noticeContent.style.display === '') {
                        noticeContent.style.display = 'block';
                        noticeToggle.textContent = 'æ³¨æ„äº‹é¡¹âˆ§';
                    } else {
                        noticeContent.style.display = 'none';
                        noticeToggle.textContent = 'æ³¨æ„äº‹é¡¹âˆ¨';
                    }
                }
        
                // åˆå§‹åŒ– noticeContent çš„ display å±æ€§
                document.addEventListener('DOMContentLoaded', () => {
                    document.getElementById('noticeContent').style.display = 'none';
                });
                </script>
            </body>
            </html>
        `;

        return new Response(html, {
            headers: { "Content-Type": "text/html;charset=utf-8" }
        });
    } catch (error) {
        console.error('å¤„ç†è¯·æ±‚æ—¶å‘ç”Ÿé”™è¯¯:', error);
        return new Response("æœåŠ¡å™¨é”™è¯¯: " + error.message, {
            status: 500,
            headers: { "Content-Type": "text/plain;charset=utf-8" }
        });
    }
}

async function resolveToIPv6(target) {
    const defaultAddress = atob('cHJveHlpcC5jbWxpdXNzc3MubmV0');
    if (!DNS64Server) {
        try {
            const response = await fetch(atob('aHR0cHM6Ly8xLjEuMS4xL2Rucy1xdWVyeT9uYW1lPW5hdDY0LmNtbGl1c3Nzcy5uZXQmdHlwZT1UWFQ='), {
                headers: { 'Accept': 'application/dns-json' }
            });

            if (!response.ok) return defaultAddress;
            const data = await response.json();
            const txtRecords = (data.Answer || []).filter(record => record.type === 16).map(record => record.data);

            if (txtRecords.length === 0) return defaultAddress;
            let txtData = txtRecords[0];
            if (txtData.startsWith('"') && txtData.endsWith('"')) txtData = txtData.slice(1, -1);
            const prefixes = txtData.replace(/\\010/g, '\n').split('\n').filter(prefix => prefix.trim());
            if (prefixes.length === 0) return defaultAddress;
            DNS64Server = prefixes[Math.floor(Math.random() * prefixes.length)];
        } catch (error) {
            console.error('DNS64ServeræŸ¥è¯¢å¤±è´¥:', error);
            return defaultAddress;
        }
    }

    // æ£€æŸ¥æ˜¯å¦ä¸ºIPv4
    function isIPv4(str) {
        const parts = str.split('.');
        return parts.length === 4 && parts.every(part => {
            const num = parseInt(part, 10);
            return num >= 0 && num <= 255 && part === num.toString();
        });
    }

    // æ£€æŸ¥æ˜¯å¦ä¸ºIPv6
    function isIPv6(str) {
        return str.includes(':') && /^[0-9a-fA-F:]+$/.test(str);
    }

    // è·å–åŸŸåçš„IPv4åœ°å€
    async function fetchIPv4(domain) {
        const url = `https://1.1.1.1/dns-query?name=${domain}&type=A`;
        const response = await fetch(url, {
            headers: { 'Accept': 'application/dns-json' }
        });

        if (!response.ok) throw new Error('DNSæŸ¥è¯¢å¤±è´¥');

        const data = await response.json();
        const ipv4s = (data.Answer || [])
            .filter(record => record.type === 1)
            .map(record => record.data);

        if (ipv4s.length === 0) throw new Error('æœªæ‰¾åˆ°IPv4åœ°å€');
        return ipv4s[Math.floor(Math.random() * ipv4s.length)];
    }

    // æŸ¥è¯¢NAT64 IPv6åœ°å€
    async function queryNAT64(domain) {
        const socket = connect({
            hostname: isIPv6(DNS64Server) ? `[${DNS64Server}]` : DNS64Server,
            port: 53
        });

        const writer = socket.writable.getWriter();
        const reader = socket.readable.getReader();

        try {
            // å‘é€DNSæŸ¥è¯¢
            const query = buildDNSQuery(domain);
            const queryWithLength = new Uint8Array(query.length + 2);
            queryWithLength[0] = query.length >> 8;
            queryWithLength[1] = query.length & 0xFF;
            queryWithLength.set(query, 2);
            await writer.write(queryWithLength);

            // è¯»å–å“åº”
            const response = await readDNSResponse(reader);
            const ipv6s = parseIPv6(response);

            return ipv6s.length > 0 ? ipv6s[0] : 'æœªæ‰¾åˆ°IPv6åœ°å€';
        } finally {
            await writer.close();
            await reader.cancel();
        }
    }

    // æ„å»ºDNSæŸ¥è¯¢åŒ…
    function buildDNSQuery(domain) {
        const buffer = new ArrayBuffer(512);
        const view = new DataView(buffer);
        let offset = 0;

        // DNSå¤´éƒ¨
        view.setUint16(offset, Math.floor(Math.random() * 65536)); offset += 2; // ID
        view.setUint16(offset, 0x0100); offset += 2; // æ ‡å¿—
        view.setUint16(offset, 1); offset += 2; // é—®é¢˜æ•°
        view.setUint16(offset, 0); offset += 6; // ç­”æ¡ˆæ•°/æƒå¨æ•°/é™„åŠ æ•°

        // åŸŸåç¼–ç 
        for (const label of domain.split('.')) {
            view.setUint8(offset++, label.length);
            for (let i = 0; i < label.length; i++) {
                view.setUint8(offset++, label.charCodeAt(i));
            }
        }
        view.setUint8(offset++, 0); // ç»“æŸæ ‡è®°

        // æŸ¥è¯¢ç±»å‹å’Œç±»
        view.setUint16(offset, 28); offset += 2; // AAAAè®°å½•
        view.setUint16(offset, 1); offset += 2; // INç±»

        return new Uint8Array(buffer, 0, offset);
    }

    // è¯»å–DNSå“åº”
    async function readDNSResponse(reader) {
        const chunks = [];
        let totalLength = 0;
        let expectedLength = null;

        while (true) {
            const { value, done } = await reader.read();
            if (done) break;

            chunks.push(value);
            totalLength += value.length;

            if (expectedLength === null && totalLength >= 2) {
                expectedLength = (chunks[0][0] << 8) | chunks[0][1];
            }

            if (expectedLength !== null && totalLength >= expectedLength + 2) {
                break;
            }
        }

        // åˆå¹¶æ•°æ®å¹¶è·³è¿‡é•¿åº¦å‰ç¼€
        const fullResponse = new Uint8Array(totalLength);
        let offset = 0;
        for (const chunk of chunks) {
            fullResponse.set(chunk, offset);
            offset += chunk.length;
        }

        return fullResponse.slice(2);
    }

    // è§£æIPv6åœ°å€
    function parseIPv6(response) {
        const view = new DataView(response.buffer);
        let offset = 12; // è·³è¿‡DNSå¤´éƒ¨

        // è·³è¿‡é—®é¢˜éƒ¨åˆ†
        while (view.getUint8(offset) !== 0) {
            offset += view.getUint8(offset) + 1;
        }
        offset += 5;

        const answers = [];
        const answerCount = view.getUint16(6); // ç­”æ¡ˆæ•°é‡

        for (let i = 0; i < answerCount; i++) {
            // è·³è¿‡åç§°
            if ((view.getUint8(offset) & 0xC0) === 0xC0) {
                offset += 2;
            } else {
                while (view.getUint8(offset) !== 0) {
                    offset += view.getUint8(offset) + 1;
                }
                offset++;
            }

            const type = view.getUint16(offset); offset += 2;
            offset += 6; // è·³è¿‡ç±»å’ŒTTL
            const dataLength = view.getUint16(offset); offset += 2;

            if (type === 28 && dataLength === 16) { // AAAAè®°å½•
                const parts = [];
                for (let j = 0; j < 8; j++) {
                    parts.push(view.getUint16(offset + j * 2).toString(16));
                }
                answers.push(parts.join(':'));
            }
            offset += dataLength;
        }

        return answers;
    }

    function convertToNAT64IPv6(ipv4Address) {
        const parts = ipv4Address.split('.');
        if (parts.length !== 4) {
            throw new Error('æ— æ•ˆçš„IPv4åœ°å€');
        }

        // å°†æ¯ä¸ªéƒ¨åˆ†è½¬æ¢ä¸º16è¿›åˆ¶
        const hex = parts.map(part => {
            const num = parseInt(part, 10);
            if (num < 0 || num > 255) {
                throw new Error('æ— æ•ˆçš„IPv4åœ°å€æ®µ');
            }
            return num.toString(16).padStart(2, '0');
        });

        // æ„é€ NAT64
        return DNS64Server.split('/96')[0] + hex[0] + hex[1] + ":" + hex[2] + hex[3];
    }

    try {
        // åˆ¤æ–­è¾“å…¥ç±»å‹å¹¶å¤„ç†
        if (isIPv6(target)) return target; // IPv6ç›´æ¥è¿”å›
        const ipv4 = isIPv4(target) ? target : await fetchIPv4(target);
        const nat64 = DNS64Server.endsWith('/96') ? convertToNAT64IPv6(ipv4) : await queryNAT64(ipv4 + atob('LmlwLjA5MDIyNy54eXo='));
        return isIPv6(nat64) ? nat64 : defaultAddress;
    } catch (error) {
        console.error('è§£æé”™è¯¯:', error);
        return defaultAddress;
    }
}

async function bestIP(request, env, txt = 'ADD.txt') {
    const country = request.cf?.country || 'CN';
    const url = new URL(request.url);
    async function getNipDomain() {
        try {
            const response = await fetch(atob('aHR0cHM6Ly9jbG91ZGZsYXJlLWRucy5jb20vZG5zLXF1ZXJ5P25hbWU9bmlwLjA5MDIyNy54eXomdHlwZT1UWFQ='), {
                headers: {
                    'Accept': 'application/dns-json'
                }
            });

            if (response.ok) {
                const data = await response.json();
                if (data.Status === 0 && data.Answer && data.Answer.length > 0) {
                    // TXTè®°å½•çš„å€¼é€šå¸¸åŒ…å«åœ¨å¼•å·ä¸­ï¼Œéœ€è¦å»é™¤å¼•å·
                    const txtRecord = data.Answer[0].data;
                    // å»é™¤é¦–å°¾çš„å¼•å·
                    const domain = txtRecord.replace(/^"(.*)"$/, '$1');
                    console.log('é€šè¿‡DoHè§£æè·å–åˆ°åŸŸå: ' + domain);
                    return domain;
                }
            }
            console.warn('DoHè§£æå¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤åŸŸå');
            return atob('bmlwLmxmcmVlLm9yZw==');
        } catch (error) {
            console.error('DoHè§£æå‡ºé”™:', error);
            return atob('aXAuMDkwMjI3Lnh5eg==');
        }
    }
    const nipDomain = await getNipDomain();
    async function GetCFIPs(ipSource = 'official', targetPort = '443') {
        try {
            let response;
            if (ipSource === 'as13335') {
                // AS13335åˆ—è¡¨
                response = await fetch('https://raw.githubusercontent.com/ipverse/asn-ip/master/as/13335/ipv4-aggregated.txt');
            } else if (ipSource === 'as209242') {
                // AS209242åˆ—è¡¨
                response = await fetch('https://raw.githubusercontent.com/ipverse/asn-ip/master/as/209242/ipv4-aggregated.txt');
            } else if (ipSource === 'as24429') {
                // AS24429åˆ—è¡¨
                response = await fetch('https://raw.githubusercontent.com/ipverse/asn-ip/master/as/24429/ipv4-aggregated.txt');
            } else if (ipSource === 'as35916') {
                // AS35916åˆ—è¡¨
                response = await fetch('https://raw.githubusercontent.com/ipverse/asn-ip/master/as/35916/ipv4-aggregated.txt');
            } else if (ipSource === 'as199524') {
                // AS199524åˆ—è¡¨
                response = await fetch('https://raw.githubusercontent.com/ipverse/asn-ip/master/as/199524/ipv4-aggregated.txt');
            } else if (ipSource === 'cm') {
                // CMæ•´ç†åˆ—è¡¨
                response = await fetch('https://raw.githubusercontent.com/cmliu/cmliu/main/CF-CIDR.txt');
            } else if (ipSource === 'proxyip') {
                // åä»£IPåˆ—è¡¨ (ç›´æ¥IPï¼ŒéCIDR)
                response = await fetch('https://raw.githubusercontent.com/cmliu/ACL4SSR/main/baipiao.txt');
                const text = response.ok ? await response.text() : '';

                // è§£æå¹¶è¿‡æ»¤ç¬¦åˆç«¯å£çš„IP
                const allLines = text.split('\n')
                    .map(line => line.trim())
                    .filter(line => line && !line.startsWith('#'));

                const validIps = [];

                for (const line of allLines) {
                    const parsedIP = parseProxyIPLine(line, targetPort);
                    if (parsedIP) {
                        validIps.push(parsedIP);
                    }
                }

                console.log(`åä»£IPåˆ—è¡¨è§£æå®Œæˆï¼Œç«¯å£${targetPort}åŒ¹é…åˆ°${validIps.length}ä¸ªæœ‰æ•ˆIP`);

                // å¦‚æœè¶…è¿‡512ä¸ªIPï¼Œéšæœºé€‰æ‹©512ä¸ª
                if (validIps.length > 512) {
                    const shuffled = [...validIps].sort(() => 0.5 - Math.random());
                    const selectedIps = shuffled.slice(0, 512);
                    console.log(`IPæ•°é‡è¶…è¿‡512ä¸ªï¼Œéšæœºé€‰æ‹©äº†${selectedIps.length}ä¸ªIP`);
                    return selectedIps;
                } else {
                    return validIps;
                }
            } else {
                // CFå®˜æ–¹åˆ—è¡¨ (é»˜è®¤)
                response = await fetch('https://www.cloudflare.com/ips-v4/');
            }

            const text = response.ok ? await response.text() : `173.245.48.0/20
103.21.244.0/22
103.22.200.0/22
103.31.4.0/22
141.101.64.0/18
108.162.192.0/18
190.93.240.0/20
188.114.96.0/20
197.234.240.0/22
198.41.128.0/17
162.158.0.0/15
104.16.0.0/13
104.24.0.0/14
172.64.0.0/13
131.0.72.0/22`;
            const cidrs = text.split('\n').filter(line => line.trim() && !line.startsWith('#'));

            const ips = new Set(); // ä½¿ç”¨Setå»é‡
            const targetCount = 512;
            let round = 1;

            // ä¸æ–­è½®æ¬¡ç”ŸæˆIPç›´åˆ°è¾¾åˆ°ç›®æ ‡æ•°é‡
            while (ips.size < targetCount) {
                console.log(`ç¬¬${round}è½®ç”ŸæˆIPï¼Œå½“å‰å·²æœ‰${ips.size}ä¸ª`);

                // æ¯è½®ä¸ºæ¯ä¸ªCIDRç”ŸæˆæŒ‡å®šæ•°é‡çš„IP
                for (const cidr of cidrs) {
                    if (ips.size >= targetCount) break;

                    const cidrIPs = generateIPsFromCIDR(cidr.trim(), round);
                    cidrIPs.forEach(ip => ips.add(ip));

                    console.log(`CIDR ${cidr} ç¬¬${round}è½®ç”Ÿæˆ${cidrIPs.length}ä¸ªIPï¼Œæ€»è®¡${ips.size}ä¸ª`);
                }

                round++;

                // é˜²æ­¢æ— é™å¾ªç¯
                if (round > 100) {
                    console.warn('è¾¾åˆ°æœ€å¤§è½®æ¬¡é™åˆ¶ï¼Œåœæ­¢ç”Ÿæˆ');
                    break;
                }
            }

            console.log(`æœ€ç»ˆç”Ÿæˆ${ips.size}ä¸ªä¸é‡å¤IP`);
            return Array.from(ips).slice(0, targetCount);
        } catch (error) {
            console.error('è·å–CF IPså¤±è´¥:', error);
            return [];
        }
    }

    // æ–°å¢ï¼šè§£æåä»£IPè¡Œçš„å‡½æ•°
    function parseProxyIPLine(line, targetPort) {
        try {
            // ç§»é™¤é¦–å°¾ç©ºæ ¼
            line = line.trim();
            if (!line) return null;

            let ip = '';
            let port = '';
            let comment = '';

            // å¤„ç†æ³¨é‡Šéƒ¨åˆ†
            if (line.includes('#')) {
                const parts = line.split('#');
                const mainPart = parts[0].trim();
                comment = parts[1].trim();

                // æ£€æŸ¥ä¸»è¦éƒ¨åˆ†æ˜¯å¦åŒ…å«ç«¯å£
                if (mainPart.includes(':')) {
                    const ipPortParts = mainPart.split(':');
                    if (ipPortParts.length === 2) {
                        ip = ipPortParts[0].trim();
                        port = ipPortParts[1].trim();
                    } else {
                        // æ ¼å¼ä¸æ­£ç¡®ï¼Œå¦‚":844347.254.171.15:8443"
                        console.warn(`æ— æ•ˆçš„IP:ç«¯å£æ ¼å¼: ${line}`);
                        return null;
                    }
                } else {
                    // æ²¡æœ‰ç«¯å£ï¼Œé»˜è®¤443
                    ip = mainPart;
                    port = '443';
                }
            } else {
                // æ²¡æœ‰æ³¨é‡Š
                if (line.includes(':')) {
                    const ipPortParts = line.split(':');
                    if (ipPortParts.length === 2) {
                        ip = ipPortParts[0].trim();
                        port = ipPortParts[1].trim();
                    } else {
                        // æ ¼å¼ä¸æ­£ç¡®
                        console.warn(`æ— æ•ˆçš„IP:ç«¯å£æ ¼å¼: ${line}`);
                        return null;
                    }
                } else {
                    // åªæœ‰IPï¼Œé»˜è®¤443ç«¯å£
                    ip = line;
                    port = '443';
                }
            }

            // éªŒè¯IPæ ¼å¼
            if (!isValidIP(ip)) {
                console.warn(`æ— æ•ˆçš„IPåœ°å€: ${ip} (æ¥æºè¡Œ: ${line})`);
                return null;
            }

            // éªŒè¯ç«¯å£æ ¼å¼
            const portNum = parseInt(port);
            if (isNaN(portNum) || portNum < 1 || portNum > 65535) {
                console.warn(`æ— æ•ˆçš„ç«¯å£å·: ${port} (æ¥æºè¡Œ: ${line})`);
                return null;
            }

            // æ£€æŸ¥ç«¯å£æ˜¯å¦åŒ¹é…
            if (port !== targetPort) {
                return null; // ç«¯å£ä¸åŒ¹é…ï¼Œè¿‡æ»¤æ‰
            }

            // æ„å»ºè¿”å›æ ¼å¼
            if (comment) {
                return ip + ':' + port + '#' + comment;
            } else {
                return ip + ':' + port;
            }

        } catch (error) {
            console.error(`è§£æIPè¡Œå¤±è´¥: ${line}`, error);
            return null;
        }
    }

    // æ–°å¢ï¼šéªŒè¯IPåœ°å€æ ¼å¼çš„å‡½æ•°
    function isValidIP(ip) {
        const ipRegex = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;
        const match = ip.match(ipRegex);

        if (!match) return false;

        // æ£€æŸ¥æ¯ä¸ªæ•°å­—æ˜¯å¦åœ¨0-255èŒƒå›´å†…
        for (let i = 1; i <= 4; i++) {
            const num = parseInt(match[i]);
            if (num < 0 || num > 255) {
                return false;
            }
        }

        return true;
    }

    function generateIPsFromCIDR(cidr, count = 1) {
        const [network, prefixLength] = cidr.split('/');
        const prefix = parseInt(prefixLength);

        // å°†IPåœ°å€è½¬æ¢ä¸º32ä½æ•´æ•°
        const ipToInt = (ip) => {
            return ip.split('.').reduce((acc, octet) => (acc << 8) + parseInt(octet), 0) >>> 0;
        };

        // å°†32ä½æ•´æ•°è½¬æ¢ä¸ºIPåœ°å€
        const intToIP = (int) => {
            return [
                (int >>> 24) & 255,
                (int >>> 16) & 255,
                (int >>> 8) & 255,
                int & 255
            ].join('.');
        };

        const networkInt = ipToInt(network);
        const hostBits = 32 - prefix;
        const numHosts = Math.pow(2, hostBits);

        // é™åˆ¶ç”Ÿæˆæ•°é‡ä¸è¶…è¿‡è¯¥CIDRçš„å¯ç”¨ä¸»æœºæ•°
        const maxHosts = numHosts - 2; // -2 æ’é™¤ç½‘ç»œåœ°å€å’Œå¹¿æ’­åœ°å€
        const actualCount = Math.min(count, maxHosts);
        const ips = new Set();

        // å¦‚æœå¯ç”¨ä¸»æœºæ•°å¤ªå°‘ï¼Œç›´æ¥è¿”å›ç©ºæ•°ç»„
        if (maxHosts <= 0) {
            return [];
        }

        // ç”ŸæˆæŒ‡å®šæ•°é‡çš„éšæœºIP
        let attempts = 0;
        const maxAttempts = actualCount * 10; // é˜²æ­¢æ— é™å¾ªç¯

        while (ips.size < actualCount && attempts < maxAttempts) {
            const randomOffset = Math.floor(Math.random() * maxHosts) + 1; // +1 é¿å…ç½‘ç»œåœ°å€
            const randomIP = intToIP(networkInt + randomOffset);
            ips.add(randomIP);
            attempts++;
        }

        return Array.from(ips);
    }

    // POSTè¯·æ±‚å¤„ç†
    if (request.method === "POST") {
        if (!env.KV) return new Response("æœªç»‘å®šKVç©ºé—´", { status: 400 });

        try {
            const contentType = request.headers.get('Content-Type');

            // å¤„ç†JSONæ ¼å¼çš„ä¿å­˜/è¿½åŠ è¯·æ±‚
            if (contentType && contentType.includes('application/json')) {
                const data = await request.json();
                const action = url.searchParams.get('action') || 'save';

                if (!data.ips || !Array.isArray(data.ips)) {
                    return new Response(JSON.stringify({ error: 'Invalid IP list' }), {
                        status: 400,
                        headers: { 'Content-Type': 'application/json' }
                    });
                }

                if (action === 'append') {
                    // è¿½åŠ æ¨¡å¼
                    const existingContent = await env.KV.get(txt) || '';
                    const newContent = data.ips.join('\n');

                    // åˆå¹¶å†…å®¹å¹¶å»é‡
                    const existingLines = existingContent ?
                        existingContent.split('\n').map(line => line.trim()).filter(line => line) :
                        [];
                    const newLines = newContent.split('\n').map(line => line.trim()).filter(line => line);

                    // ä½¿ç”¨Setè¿›è¡Œå»é‡
                    const allLines = [...existingLines, ...newLines];
                    const uniqueLines = [...new Set(allLines)];
                    const combinedContent = uniqueLines.join('\n');

                    // æ£€æŸ¥åˆå¹¶åçš„å†…å®¹å¤§å°
                    if (combinedContent.length > 24 * 1024 * 1024) {
                        return new Response(JSON.stringify({
                            error: `è¿½åŠ å¤±è´¥ï¼šåˆå¹¶åå†…å®¹è¿‡å¤§ï¼ˆ${(combinedContent.length / 1024 / 1024).toFixed(2)}MBï¼‰ï¼Œè¶…è¿‡KVå­˜å‚¨é™åˆ¶ï¼ˆ24MBï¼‰`
                        }), {
                            status: 400,
                            headers: { 'Content-Type': 'application/json' }
                        });
                    }

                    await env.KV.put(txt, combinedContent);

                    const addedCount = uniqueLines.length - existingLines.length;
                    const duplicateCount = newLines.length - addedCount;

                    let message = `æˆåŠŸè¿½åŠ  ${addedCount} ä¸ªæ–°çš„ä¼˜é€‰IPï¼ˆåŸæœ‰ ${existingLines.length} ä¸ªï¼Œç°å…± ${uniqueLines.length} ä¸ªï¼‰`;
                    if (duplicateCount > 0) {
                        message += `ï¼Œå·²å»é‡ ${duplicateCount} ä¸ªé‡å¤é¡¹`;
                    }

                    return new Response(JSON.stringify({
                        success: true,
                        message: message
                    }), {
                        headers: { 'Content-Type': 'application/json' }
                    });
                } else {
                    // ä¿å­˜æ¨¡å¼ï¼ˆè¦†ç›–ï¼‰
                    const content = data.ips.join('\n');

                    // æ£€æŸ¥å†…å®¹å¤§å°
                    if (content.length > 24 * 1024 * 1024) {
                        return new Response(JSON.stringify({
                            error: 'å†…å®¹è¿‡å¤§ï¼Œè¶…è¿‡KVå­˜å‚¨é™åˆ¶ï¼ˆ24MBï¼‰'
                        }), {
                            status: 400,
                            headers: { 'Content-Type': 'application/json' }
                        });
                    }

                    await env.KV.put(txt, content);

                    return new Response(JSON.stringify({
                        success: true,
                        message: `æˆåŠŸä¿å­˜ ${data.ips.length} ä¸ªä¼˜é€‰IP`
                    }), {
                        headers: { 'Content-Type': 'application/json' }
                    });
                }
            } else {
                // å¤„ç†æ™®é€šæ–‡æœ¬æ ¼å¼çš„ä¿å­˜è¯·æ±‚ï¼ˆå…¼å®¹åŸæœ‰åŠŸèƒ½ï¼‰
                const content = await request.text();
                await env.KV.put(txt, content);
                return new Response("ä¿å­˜æˆåŠŸ");
            }

        } catch (error) {
            console.error('å¤„ç†POSTè¯·æ±‚æ—¶å‘ç”Ÿé”™è¯¯:', error);
            return new Response(JSON.stringify({
                error: 'æ“ä½œå¤±è´¥: ' + error.message
            }), {
                status: 500,
                headers: { 'Content-Type': 'application/json' }
            });
        }
    }

    // GETè¯·æ±‚éƒ¨åˆ†
    let content = '';
    let hasKV = !!env.KV;

    if (hasKV) {
        try {
            content = await env.KV.get(txt) || '';
        } catch (error) {
            console.error('è¯»å–KVæ—¶å‘ç”Ÿé”™è¯¯:', error);
            content = 'è¯»å–æ•°æ®æ—¶å‘ç”Ÿé”™è¯¯: ' + error.message;
        }
    }

    // ç§»é™¤åˆå§‹IPåŠ è½½ï¼Œæ”¹ä¸ºåœ¨å‰ç«¯åŠ¨æ€åŠ è½½
    const cfIPs = []; // åˆå§‹ä¸ºç©ºæ•°ç»„

    // åˆ¤æ–­æ˜¯å¦ä¸ºä¸­å›½ç”¨æˆ·
    const isChina = country === 'CN';
    const countryDisplayClass = isChina ? '' : 'proxy-warning';
    const countryDisplayText = isChina ? `${country}` : `${country} âš ï¸`;

    const html = `
    <!DOCTYPE html>
    <html>
    <head>
    <title>Cloudflare IPä¼˜é€‰</title>
    <style>
        body {
            width: 80%;
            margin: 0 auto;
            font-family: Tahoma, Verdana, Arial, sans-serif;
            padding: 20px;
        }
        .ip-list {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            max-height: 400px;
            overflow-y: auto;
        }
        .ip-item {
            margin: 2px 0;
            font-family: monospace;
        }
        .stats {
            background-color: #e3f2fd;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .test-info {
            margin-top: 15px;
            padding: 12px;
            background-color: #f3e5f5;
            border: 1px solid #ce93d8;
            border-radius: 6px;
            color: #4a148c;
        }
        .test-info p {
            margin: 0;
            font-size: 14px;
            line-height: 1.5;
        }
        .proxy-warning {
            color: #d32f2f !important;
            font-weight: bold !important;
            font-size: 1.1em;
        }
        .warning-notice {
            background-color: #ffebee;
            border: 2px solid #f44336;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            color: #c62828;
        }
        .warning-notice h3 {
            margin: 0 0 10px 0;
            color: #d32f2f;
            font-size: 1.2em;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .warning-notice p {
            margin: 8px 0;
            line-height: 1.5;
        }
        .warning-notice ul {
            margin: 10px 0 10px 20px;
            line-height: 1.6;
        }
        .test-controls {
            margin: 20px 0;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 5px;
        }
        .port-selector {
            margin: 10px 0;
        }
        .port-selector label {
            font-weight: bold;
            margin-right: 10px;
        }
        .port-selector select {
            padding: 5px 10px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }
        .test-button {
            background-color: #4CAF50;
            color: white;
            padding: 15px 32px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            transition: background-color 0.3s;
        }
        .test-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .save-button {
            background-color: #2196F3;
            color: white;
            padding: 15px 32px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            transition: background-color 0.3s;
        }
        .save-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .save-button:not(:disabled):hover {
            background-color: #1976D2;
        }
        .append-button {
            background-color: #FF9800;
            color: white;
            padding: 15px 32px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            transition: background-color 0.3s;
        }
        .append-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .append-button:not(:disabled):hover {
            background-color: #F57C00;
        }
        .edit-button {
            background-color: #9C27B0;
            color: white;
            padding: 15px 32px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            transition: background-color 0.3s;
        }
        .edit-button:hover {
            background-color: #7B1FA2;
        }
        .back-button {
            background-color: #607D8B;
            color: white;
            padding: 15px 32px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            transition: background-color 0.3s;
        }
        .back-button:hover {
            background-color: #455A64;
        }
        .save-warning {
            margin-top: 10px;
            background-color: #fff3e0;
            border: 2px solid #ff9800;
            border-radius: 6px;
            padding: 12px;
            color: #e65100;
            font-weight: bold;
        }
        .save-warning small {
            font-size: 14px;
            line-height: 1.5;
            display: block;
        }
        .message {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            display: none;
        }
        .message.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .message.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .progress {
            width: 100%;
            background-color: #f0f0f0;
            border-radius: 5px;
            margin: 10px 0;
        }
        .progress-bar {
            width: 0%;
            height: 20px;
            background-color: #4CAF50;
            border-radius: 5px;
            transition: width 0.3s;
        }
        .good-latency { color: #4CAF50; font-weight: bold; }
        .medium-latency { color: #FF9800; font-weight: bold; }
        .bad-latency { color: #f44336; font-weight: bold; }
        .show-more-section {
            text-align: center;
            margin: 10px 0;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
        .show-more-btn {
            background-color: #607D8B;
            color: white;
            padding: 8px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        .show-more-btn:hover {
            background-color: #455A64;
        }
        .ip-display-info {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }
        .save-tip {
            margin-top: 15px;
            padding: 12px;
            background-color: #e8f5e8;
            border: 1px solid #4CAF50;
            border-radius: 6px;
            color: #2e7d32;
            font-size: 14px;
            line-height: 1.5;
        }
        .save-tip strong {
            color: #1b5e20;
        }
        .warm-tips {
            margin: 20px 0;
            padding: 15px;
            background-color: #fff3e0;
            border: 2px solid #ff9800;
            border-radius: 8px;
            color: #e65100;
        }
        .warm-tips h3 {
            margin: 0 0 10px 0;
            color: #f57c00;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .warm-tips p {
            margin: 8px 0;
            line-height: 1.6;
            font-size: 14px;
        }
        .warm-tips ul {
            margin: 10px 0 10px 20px;
            line-height: 1.6;
        }
        .warm-tips li {
            margin: 5px 0;
            font-size: 14px;
        }
        .warm-tips strong {
            color: #e65100;
            font-weight: bold;
        }
        .region-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }
        .region-btn {
            padding: 6px 12px;
            background-color: #e0e0e0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        .region-btn:hover {
            background-color: #d5d5d5;
        }
        .region-btn.active {
            background-color: #2196F3;
            color: white;
        }
    </style>
    </head>
    <body>
    <h1>åœ¨çº¿ä¼˜é€‰IP</h1>
    
    ${!isChina ? `
    <div class="warning-notice">
        <h3>ğŸš¨ ä»£ç†æ£€æµ‹è­¦å‘Š</h3>
        <p><strong>æ£€æµ‹åˆ°æ‚¨å½“å‰å¾ˆå¯èƒ½å¤„äºä»£ç†/VPNç¯å¢ƒä¸­ï¼</strong></p>
        <p>åœ¨ä»£ç†çŠ¶æ€ä¸‹è¿›è¡Œçš„IPä¼˜é€‰æµ‹è¯•ç»“æœå°†ä¸å‡†ç¡®ï¼Œå¯èƒ½å¯¼è‡´ï¼š</p>
        <ul>
            <li>å»¶è¿Ÿæ•°æ®å¤±çœŸï¼Œæ— æ³•åæ˜ çœŸå®ç½‘ç»œçŠ¶å†µ</li>
            <li>ä¼˜é€‰å‡ºçš„IPåœ¨ç›´è¿ç¯å¢ƒä¸‹è¡¨ç°ä¸ä½³</li>
            <li>æµ‹è¯•ç»“æœå¯¹å®é™…ä½¿ç”¨åœºæ™¯å‚è€ƒä»·å€¼æœ‰é™</li>
        </ul>
        <p><strong>å»ºè®®æ“ä½œï¼š</strong>è¯·å…³é—­æ‰€æœ‰ä»£ç†è½¯ä»¶ï¼ˆVPNã€ç§‘å­¦ä¸Šç½‘å·¥å…·ç­‰ï¼‰ï¼Œç¡®ä¿å¤„äºç›´è¿ç½‘ç»œç¯å¢ƒåé‡æ–°è®¿é—®æœ¬é¡µé¢ã€‚</p>
    </div>
    ` : ''}

    <div class="stats">
        <h2>ç»Ÿè®¡ä¿¡æ¯</h2>
        <p><strong>æ‚¨çš„å›½å®¶ï¼š</strong><span class="${countryDisplayClass}">${countryDisplayText}</span></p>
        <p><strong>è·å–åˆ°çš„IPæ€»æ•°ï¼š</strong><span id="ip-count">ç‚¹å‡»å¼€å§‹æµ‹è¯•ååŠ è½½</span></p>
        <p><strong>æµ‹è¯•è¿›åº¦ï¼š</strong><span id="progress-text">æœªå¼€å§‹</span></p>
        <div class="progress">
            <div class="progress-bar" id="progress-bar"></div>
        </div>
        <div class="test-info">
            <p><strong>ğŸ“Š æµ‹è¯•è¯´æ˜ï¼š</strong>å½“å‰ä¼˜é€‰æ–¹å¼ä»…è¿›è¡Œç½‘ç»œå»¶è¿Ÿæµ‹è¯•ï¼Œä¸»è¦è¯„ä¼°è¿æ¥å“åº”é€Ÿåº¦ï¼Œå¹¶æœªåŒ…å«å¸¦å®½é€Ÿåº¦æµ‹è¯•ã€‚å»¶è¿Ÿæµ‹è¯•å¯å¿«é€Ÿç­›é€‰å‡ºå“åº”æœ€å¿«çš„IPèŠ‚ç‚¹ï¼Œé€‚åˆæ—¥å¸¸ä½¿ç”¨åœºæ™¯çš„åˆæ­¥ä¼˜é€‰ã€‚</p>
        </div>
    </div>
    
    <div class="warm-tips" id="warm-tips">
        <h3>ğŸ’¡ æ¸©é¦¨æç¤º</h3>
        <p><strong>ä¼˜é€‰å®Œæˆä½†æµ‹è¯•"çœŸè¿æ¥å»¶è¿Ÿ"ä¸º -1ï¼Ÿ</strong>è¿™å¾ˆæœ‰å¯èƒ½æ˜¯æ‚¨çš„ç½‘ç»œè¿è¥å•†å¯¹ä½ çš„è¯·æ±‚è¿›è¡Œäº†é˜»æ–­ã€‚</p>
        <p><strong>å»ºè®®å°è¯•ä»¥ä¸‹è§£å†³æ–¹æ¡ˆï¼š</strong></p>
        <ul>
            <li><strong>æ›´æ¢ç«¯å£ï¼š</strong>å°è¯•ä½¿ç”¨å…¶ä»–ç«¯å£ï¼ˆå¦‚ 2053ã€2083ã€2087ã€2096ã€8443ï¼‰</li>
            <li><strong>æ›´æ¢IPåº“ï¼š</strong>åˆ‡æ¢åˆ°ä¸åŒçš„IPæ¥æºï¼ˆCMæ•´ç†åˆ—è¡¨ã€AS13335ã€AS209242åˆ—è¡¨ç­‰ï¼Œä½†å¦‚æœä½ ä¸æ˜ç™½AS24429å’ŒAS199524æ„å‘³ç€ä»€ä¹ˆï¼Œé‚£å°±ä¸è¦é€‰ã€‚ï¼‰</li>
            <li><strong>æ›´æ¢è‡ªå®šä¹‰åŸŸåï¼š</strong>å¦‚æœæ‚¨ä½¿ç”¨çš„è¿˜æ˜¯å…è´¹åŸŸåï¼Œé‚£ä¹ˆæ‚¨æ›´åº”è¯¥å°è¯•ä¸€ä¸‹æ›´æ¢è‡ªå®šä¹‰åŸŸ</li>
        </ul>
        <p>ğŸ’¡ <strong>å°è´´å£«ï¼š</strong>ä¸åŒåœ°åŒºå’Œç½‘ç»œç¯å¢ƒå¯¹å„ç«¯å£çš„æ”¯æŒæƒ…å†µå¯èƒ½ä¸åŒï¼Œå¤šå°è¯•å‡ ä¸ªç«¯å£ç»„åˆé€šå¸¸èƒ½æ‰¾åˆ°é€‚åˆçš„IPã€‚</p>
    </div>

    <div class="test-controls">
        <div class="port-selector">
            <label for="ip-source-select">IPåº“ï¼š</label>
            <select id="ip-source-select">
                <option value="official">CFå®˜æ–¹åˆ—è¡¨</option>
                <option value="cm">CMæ•´ç†åˆ—è¡¨</option>
                <option value="as13335">AS13335åˆ—è¡¨</option>
                <option value="as209242">AS209242åˆ—è¡¨</option>
                <option value="as24429">AS24429åˆ—è¡¨(Alibaba)</option>
                <option value="as199524">AS199524åˆ—è¡¨(G-Core)</option>
                <option value="proxyip">åä»£IPåˆ—è¡¨</option>
            </select>

            <label for="port-select" style="margin-left: 20px;">ç«¯å£ï¼š</label>
            <select id="port-select">
                <option value="443">443</option>
                <option value="2053">2053</option>
                <option value="2083">2083</option>
                <option value="2087">2087</option>
                <option value="2096">2096</option>
                <option value="8443">8443</option>
            </select>
        </div>
        <div class="button-group">
            <button class="test-button" id="test-btn" onclick="startTest()">å¼€å§‹å»¶è¿Ÿæµ‹è¯•</button>
            <button class="save-button" id="save-btn" onclick="saveIPs()" disabled>è¦†ç›–ä¿å­˜ä¼˜é€‰IP</button>
            <button class="append-button" id="append-btn" onclick="appendIPs()" disabled>è¿½åŠ ä¿å­˜ä¼˜é€‰IP</button>
            <button class="edit-button" id="edit-btn" onclick="goEdit()">ç¼–è¾‘ä¼˜é€‰åˆ—è¡¨</button>
            <button class="back-button" id="back-btn" onclick="goBack()">è¿”å›é…ç½®é¡µ</button>
        </div>
        <div class="save-warning">
            <small>âš ï¸ é‡è¦æé†’ï¼š"è¦†ç›–ä¿å­˜ä¼˜é€‰IP"ä¼šå®Œå…¨è¦†ç›–å½“å‰ addresses/ADD ä¼˜é€‰å†…å®¹ï¼Œè¯·æ…é‡è€ƒè™‘ï¼å»ºè®®ä¼˜å…ˆä½¿ç”¨"è¿½åŠ ä¿å­˜ä¼˜é€‰IP"åŠŸèƒ½ã€‚</small>
        </div>
        <div class="save-tip">
            <strong>ğŸ’¡ ä¿å­˜æç¤ºï¼š</strong>[<strong>è¦†ç›–ä¿å­˜ä¼˜é€‰IP</strong>] å’Œ [<strong>è¿½åŠ ä¿å­˜ä¼˜é€‰IP</strong>] åŠŸèƒ½ä»…ä¼šä¿å­˜å»¶è¿Ÿæœ€ä½çš„<strong>å‰16ä¸ªä¼˜é€‰IP</strong>ã€‚å¦‚éœ€æ·»åŠ æ›´å¤šIPæˆ–è¿›è¡Œè‡ªå®šä¹‰ç¼–è¾‘ï¼Œè¯·ä½¿ç”¨ [<strong>ç¼–è¾‘ä¼˜é€‰åˆ—è¡¨</strong>] åŠŸèƒ½ã€‚
        </div>
        <div id="message" class="message"></div>
    </div>
    
    <h2>IPåˆ—è¡¨ <span id="result-count"></span></h2>
    <div class="ip-display-info" id="ip-display-info"></div>
    <div id="region-filter" style="margin: 15px 0; display: none;"></div>
    <div class="ip-list" id="ip-list">
        <div class="ip-item">è¯·é€‰æ‹©ç«¯å£å’ŒIPåº“ï¼Œç„¶åç‚¹å‡»"å¼€å§‹å»¶è¿Ÿæµ‹è¯•"åŠ è½½IPåˆ—è¡¨</div>
    </div>
    <div class="show-more-section" id="show-more-section" style="display: none;">
        <button class="show-more-btn" id="show-more-btn" onclick="toggleShowMore()">æ˜¾ç¤ºæ›´å¤š</button>
    </div>
    
    <script>
        let originalIPs = []; // æ”¹ä¸ºåŠ¨æ€åŠ è½½
        let testResults = [];
        let displayedResults = []; // æ–°å¢ï¼šå­˜å‚¨å½“å‰æ˜¾ç¤ºçš„ç»“æœ
        let showingAll = false; // æ–°å¢ï¼šæ ‡è®°æ˜¯å¦æ˜¾ç¤ºå…¨éƒ¨å†…å®¹
        let currentDisplayType = 'loading'; // æ–°å¢ï¼šå½“å‰æ˜¾ç¤ºç±»å‹ 'loading' | 'results'
        let cloudflareLocations = {}; // æ–°å¢ï¼šå­˜å‚¨Cloudflareä½ç½®ä¿¡æ¯
        
        // æ–°å¢ï¼šæœ¬åœ°å­˜å‚¨ç®¡ç†
        const StorageKeys = {
            PORT: 'cf-ip-test-port',
            IP_SOURCE: 'cf-ip-test-source'
        };
        
        // æ–°å¢ï¼šåŠ è½½Cloudflareä½ç½®ä¿¡æ¯
        async function loadCloudflareLocations() {
            try {
                const response = await fetch('https://speed.cloudflare.com/locations');
                if (response.ok) {
                    const locations = await response.json();
                    // è½¬æ¢ä¸ºä»¥iataä¸ºkeyçš„å¯¹è±¡ï¼Œä¾¿äºå¿«é€ŸæŸ¥æ‰¾
                    cloudflareLocations = {};
                    locations.forEach(location => {
                        cloudflareLocations[location.iata] = location;
                    });
                    console.log('Cloudflareä½ç½®ä¿¡æ¯åŠ è½½æˆåŠŸ:', Object.keys(cloudflareLocations).length, 'ä¸ªä½ç½®');
                } else {
                    console.warn('æ— æ³•åŠ è½½Cloudflareä½ç½®ä¿¡æ¯ï¼Œå°†ä½¿ç”¨åŸå§‹coloå€¼');
                }
            } catch (error) {
                console.error('åŠ è½½Cloudflareä½ç½®ä¿¡æ¯å¤±è´¥:', error);
                console.warn('å°†ä½¿ç”¨åŸå§‹coloå€¼');
            }
        }
        
        // åˆå§‹åŒ–é¡µé¢è®¾ç½®
        function initializeSettings() {
            const portSelect = document.getElementById('port-select');
            const ipSourceSelect = document.getElementById('ip-source-select');
            
            // ä»æœ¬åœ°å­˜å‚¨è¯»å–ä¸Šæ¬¡çš„é€‰æ‹©
            const savedPort = localStorage.getItem(StorageKeys.PORT);
            const savedIPSource = localStorage.getItem(StorageKeys.IP_SOURCE);
            
            // æ¢å¤ç«¯å£é€‰æ‹©
            if (savedPort && portSelect.querySelector(\`option[value="\${savedPort}"]\`)) {
                portSelect.value = savedPort;
            } else {
                portSelect.value = '8443'; // é»˜è®¤å€¼
            }
            
            // æ¢å¤IPåº“é€‰æ‹©
            if (savedIPSource && ipSourceSelect.querySelector(\`option[value="\${savedIPSource}"]\`)) {
                ipSourceSelect.value = savedIPSource;
            } else {
                ipSourceSelect.value = 'official'; // é»˜è®¤å€¼æ”¹ä¸ºCFå®˜æ–¹åˆ—è¡¨
            }
            
            // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨ä¿å­˜é€‰æ‹©
            portSelect.addEventListener('change', function() {
                localStorage.setItem(StorageKeys.PORT, this.value);
            });
            
            ipSourceSelect.addEventListener('change', function() {
                localStorage.setItem(StorageKeys.IP_SOURCE, this.value);
            });
        }
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–è®¾ç½®
        document.addEventListener('DOMContentLoaded', async function() {
            // å…ˆåŠ è½½Cloudflareä½ç½®ä¿¡æ¯
            await loadCloudflareLocations();
            // ç„¶ååˆå§‹åŒ–é¡µé¢è®¾ç½®
            initializeSettings();
        });
        
        // æ–°å¢ï¼šåˆ‡æ¢æ˜¾ç¤ºæ›´å¤š/æ›´å°‘
        function toggleShowMore() {
            // åœ¨æµ‹è¯•è¿‡ç¨‹ä¸­ä¸å…è®¸åˆ‡æ¢æ˜¾ç¤º
            if (currentDisplayType === 'testing') {
                return;
            }
            
            showingAll = !showingAll;
            
            if (currentDisplayType === 'loading') {
                displayLoadedIPs();
            } else if (currentDisplayType === 'results') {
                displayResults();
            }
        }
        
        // æ–°å¢ï¼šæ˜¾ç¤ºåŠ è½½çš„IPåˆ—è¡¨
        function displayLoadedIPs() {
            const ipList = document.getElementById('ip-list');
            const showMoreSection = document.getElementById('show-more-section');
            const showMoreBtn = document.getElementById('show-more-btn');
            const ipDisplayInfo = document.getElementById('ip-display-info');
            
            if (originalIPs.length === 0) {
                ipList.innerHTML = '<div class="ip-item">åŠ è½½IPåˆ—è¡¨å¤±è´¥ï¼Œè¯·é‡è¯•</div>';
                showMoreSection.style.display = 'none';
                ipDisplayInfo.textContent = '';
                return;
            }
            
            const displayCount = showingAll ? originalIPs.length : Math.min(originalIPs.length, 16);
            const displayIPs = originalIPs.slice(0, displayCount);
            
            // æ›´æ–°æ˜¾ç¤ºä¿¡æ¯
            if (originalIPs.length <= 16) {
                ipDisplayInfo.textContent = \`æ˜¾ç¤ºå…¨éƒ¨ \${originalIPs.length} ä¸ªIP\`;
                showMoreSection.style.display = 'none';
            } else {
                ipDisplayInfo.textContent = \`æ˜¾ç¤ºå‰ \${displayCount} ä¸ªIPï¼Œå…±åŠ è½½ \${originalIPs.length} ä¸ªIP\`;
                // åªåœ¨éæµ‹è¯•çŠ¶æ€ä¸‹æ˜¾ç¤º"æ˜¾ç¤ºæ›´å¤š"æŒ‰é’®
                if (currentDisplayType !== 'testing') {
                    showMoreSection.style.display = 'block';
                    showMoreBtn.textContent = showingAll ? 'æ˜¾ç¤ºæ›´å°‘' : 'æ˜¾ç¤ºæ›´å¤š';
                    showMoreBtn.disabled = false;
                } else {
                    showMoreSection.style.display = 'none';
                }
            }
            
            // æ˜¾ç¤ºIPåˆ—è¡¨
            ipList.innerHTML = displayIPs.map(ip => \`<div class="ip-item">\${ip}</div>\`).join('');
        }
        
        function showMessage(text, type = 'success') {
            const messageDiv = document.getElementById('message');
            messageDiv.textContent = text;
            messageDiv.className = \`message \${type}\`;
            messageDiv.style.display = 'block';
            
            // 3ç§’åè‡ªåŠ¨éšè—æ¶ˆæ¯
            setTimeout(() => {
                messageDiv.style.display = 'none';
            }, 3000);
        }
        
        function updateButtonStates() {
            const saveBtn = document.getElementById('save-btn');
            const appendBtn = document.getElementById('append-btn');
            const hasResults = displayedResults.length > 0;
            
            saveBtn.disabled = !hasResults;
            appendBtn.disabled = !hasResults;
        }
        
        function disableAllButtons() {
            const testBtn = document.getElementById('test-btn');
            const saveBtn = document.getElementById('save-btn');
            const appendBtn = document.getElementById('append-btn');
            const editBtn = document.getElementById('edit-btn');
            const backBtn = document.getElementById('back-btn');
            const portSelect = document.getElementById('port-select');
            const ipSourceSelect = document.getElementById('ip-source-select');
            
            testBtn.disabled = true;
            saveBtn.disabled = true;
            appendBtn.disabled = true;
            editBtn.disabled = true;
            backBtn.disabled = true;
            portSelect.disabled = true;
            ipSourceSelect.disabled = true;
        }
        
        function enableButtons() {
            const testBtn = document.getElementById('test-btn');
            const editBtn = document.getElementById('edit-btn');
            const backBtn = document.getElementById('back-btn');
            const portSelect = document.getElementById('port-select');
            const ipSourceSelect = document.getElementById('ip-source-select');
            
            testBtn.disabled = false;
            editBtn.disabled = false;
            backBtn.disabled = false;
            portSelect.disabled = false;
            ipSourceSelect.disabled = false;
            updateButtonStates();
        }
        
        async function saveIPs() {
            // ä½¿ç”¨å½“å‰æ˜¾ç¤ºçš„ç»“æœè€Œä¸æ˜¯å…¨éƒ¨ç»“æœ
            let ipsToSave = [];
            if (document.getElementById('region-filter') && document.getElementById('region-filter').style.display !== 'none') {
                // å¦‚æœåœ°åŒºç­›é€‰å™¨å¯è§ï¼Œä½¿ç”¨ç­›é€‰åçš„ç»“æœ
                ipsToSave = displayedResults;
            } else {
                // å¦åˆ™ä½¿ç”¨å…¨éƒ¨æµ‹è¯•ç»“æœ
                ipsToSave = testResults;
            }
            
            if (ipsToSave.length === 0) {
                showMessage('æ²¡æœ‰å¯ä¿å­˜çš„IPç»“æœ', 'error');
                return;
            }
            
            const saveBtn = document.getElementById('save-btn');
            const originalText = saveBtn.textContent;
            
            // ç¦ç”¨æ‰€æœ‰æŒ‰é’®
            disableAllButtons();
            saveBtn.textContent = 'ä¿å­˜ä¸­...';
            
            try {
                // åªä¿å­˜å‰16ä¸ªæœ€ä¼˜IP
                const saveCount = Math.min(ipsToSave.length, 16);
                const ips = ipsToSave.slice(0, saveCount).map(result => result.display);
                
                const response = await fetch('?action=save', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ ips })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showMessage(data.message + 'ï¼ˆå·²ä¿å­˜å‰' + saveCount + 'ä¸ªæœ€ä¼˜IPï¼‰', 'success');
                } else {
                    showMessage(data.error || 'ä¿å­˜å¤±è´¥', 'error');
                }
                
            } catch (error) {
                showMessage('ä¿å­˜å¤±è´¥: ' + error.message, 'error');
            } finally {
                saveBtn.textContent = originalText;
                enableButtons();
            }
        }
        
        async function appendIPs() {
            // ä½¿ç”¨å½“å‰æ˜¾ç¤ºçš„ç»“æœè€Œä¸æ˜¯å…¨éƒ¨ç»“æœ
            let ipsToAppend = [];
            if (document.getElementById('region-filter') && document.getElementById('region-filter').style.display !== 'none') {
                // å¦‚æœåœ°åŒºç­›é€‰å™¨å¯è§ï¼Œä½¿ç”¨ç­›é€‰åçš„ç»“æœ
                ipsToAppend = displayedResults;
            } else {
                // å¦åˆ™ä½¿ç”¨å…¨éƒ¨æµ‹è¯•ç»“æœ
                ipsToAppend = testResults;
            }
            
            if (ipsToAppend.length === 0) {
                showMessage('æ²¡æœ‰å¯è¿½åŠ çš„IPç»“æœ', 'error');
                return;
            }
            
            const appendBtn = document.getElementById('append-btn');
            const originalText = appendBtn.textContent;
            
            // ç¦ç”¨æ‰€æœ‰æŒ‰é’®
            disableAllButtons();
            appendBtn.textContent = 'è¿½åŠ ä¸­...';
            
            try {
                // åªè¿½åŠ å‰16ä¸ªæœ€ä¼˜IP
                const saveCount = Math.min(ipsToAppend.length, 16);
                const ips = ipsToAppend.slice(0, saveCount).map(result => result.display);
                
                const response = await fetch('?action=append', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ ips })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showMessage(data.message + 'ï¼ˆå·²è¿½åŠ å‰' + saveCount + 'ä¸ªæœ€ä¼˜IPï¼‰', 'success');
                } else {
                    showMessage(data.error || 'è¿½åŠ å¤±è´¥', 'error');
                }
                
            } catch (error) {
                showMessage('è¿½åŠ å¤±è´¥: ' + error.message, 'error');
            } finally {
                appendBtn.textContent = originalText;
                enableButtons();
            }
        }
        
        function goEdit() {
            const currentUrl = window.location.href;
            const parentUrl = currentUrl.substring(0, currentUrl.lastIndexOf('/'));
            window.location.href = parentUrl + '/edit';
        }
        
        function goBack() {
            const currentUrl = window.location.href;
            const parentUrl = currentUrl.substring(0, currentUrl.lastIndexOf('/'));
            window.location.href = parentUrl;
        }
        
        async function testIP(ip, port) {
            const timeout = 5000; // å¢åŠ è¶…æ—¶æ—¶é—´åˆ°5ç§’
            
            // è§£æIPæ ¼å¼
            const parsedIP = parseIPFormat(ip, port);
            if (!parsedIP) {
                return null;
            }
            
            // è¿›è¡Œæµ‹è¯•ï¼Œæœ€å¤šé‡è¯•3æ¬¡
            let lastError = null;
            for (let attempt = 1; attempt <= 3; attempt++) {
                const result = await singleTest(parsedIP.host, parsedIP.port, timeout);
                if (result) {
                    console.log(\`IP \${parsedIP.host}:\${parsedIP.port} ç¬¬\${attempt}æ¬¡æµ‹è¯•æˆåŠŸ: \${result.latency}ms, colo: \${result.colo}, ç±»å‹: \${result.type}\`);
                    
                    // æ ¹æ®coloå­—æ®µè·å–å›½å®¶ä»£ç 
                    const locationCode = cloudflareLocations[result.colo] ? cloudflareLocations[result.colo].cca2 : result.colo;
                    
                    // ç”Ÿæˆæ˜¾ç¤ºæ ¼å¼
                    const typeText = result.type === 'official' ? 'å®˜æ–¹ä¼˜é€‰' : 'åä»£ä¼˜é€‰';
                    const display = \`\${parsedIP.host}:\${parsedIP.port}#\${locationCode} \${typeText} \${result.latency}ms\`;
                    
                    return {
                        ip: parsedIP.host,
                        port: parsedIP.port,
                        latency: result.latency,
                        colo: result.colo,
                        type: result.type,
                        locationCode: locationCode,
                        comment: \`\${locationCode} \${typeText}\`,
                        display: display
                    };
                } else {
                    console.log(\`IP \${parsedIP.host}:\${parsedIP.port} ç¬¬\${attempt}æ¬¡æµ‹è¯•å¤±è´¥\`);
                    if (attempt < 3) {
                        // çŸ­æš‚å»¶è¿Ÿåé‡è¯•
                        await new Promise(resolve => setTimeout(resolve, 200));
                    }
                }
            }
            
            return null; // æ‰€æœ‰å°è¯•éƒ½å¤±è´¥
        }
        
        // æ–°å¢ï¼šè§£æIPæ ¼å¼çš„å‡½æ•°
        function parseIPFormat(ipString, defaultPort) {
            try {
                let host, port, comment;
                
                // å…ˆå¤„ç†æ³¨é‡Šéƒ¨åˆ†ï¼ˆ#ä¹‹åçš„å†…å®¹ï¼‰
                let mainPart = ipString;
                if (ipString.includes('#')) {
                    const parts = ipString.split('#');
                    mainPart = parts[0];
                    comment = parts[1];
                }
                
                // å¤„ç†ç«¯å£éƒ¨åˆ†
                if (mainPart.includes(':')) {
                    const parts = mainPart.split(':');
                    host = parts[0];
                    port = parseInt(parts[1]);
                } else {
                    host = mainPart;
                    port = parseInt(defaultPort);
                }
                
                // éªŒè¯IPæ ¼å¼
                if (!host || !port || isNaN(port)) {
                    return null;
                }
                
                return {
                    host: host.trim(),
                    port: port,
                    comment: comment ? comment.trim() : null
                };
            } catch (error) {
                console.error('è§£æIPæ ¼å¼å¤±è´¥:', ipString, error);
                return null;
            }
        }
        
        async function singleTest(ip, port, timeout) {
            // å…ˆè¿›è¡Œé¢„è¯·æ±‚ä»¥ç¼“å­˜DNSè§£æç»“æœ
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), timeout);
                const parts = ip.split('.').map(part => {
                    const hex = parseInt(part, 10).toString(16);
                    return hex.length === 1 ? '0' + hex : hex; // è¡¥é›¶
                });
                const nip = parts.join('');
                
                // é¢„è¯·æ±‚ï¼Œä¸è®¡å…¥å»¶è¿Ÿæ—¶é—´
                await fetch('https://' + nip + '.${nipDomain}:' + port + '/cdn-cgi/trace', {
                    signal: controller.signal,
                    mode: 'cors'
                });
                
                clearTimeout(timeoutId);
            } catch (preRequestError) {
                // é¢„è¯·æ±‚å¤±è´¥å¯ä»¥å¿½ç•¥ï¼Œç»§ç»­è¿›è¡Œæ­£å¼æµ‹è¯•
                console.log('é¢„è¯·æ±‚å¤±è´¥ (' + ip + ':' + port + '):', preRequestError.message);
            }
            
            // æ­£å¼å»¶è¿Ÿæµ‹è¯•
            const startTime = Date.now();
            
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), timeout);
                const parts = ip.split('.').map(part => {
                    const hex = parseInt(part, 10).toString(16);
                    return hex.length === 1 ? '0' + hex : hex; // è¡¥é›¶
                });
                const nip = parts.join('');
                const response = await fetch('https://' + nip + '.${nipDomain}:' + port + '/cdn-cgi/trace', {
                    signal: controller.signal,
                    mode: 'cors'
                });
                
                clearTimeout(timeoutId);
                
                // æ£€æŸ¥å“åº”çŠ¶æ€
                if (response.status === 200) {
                    const latency = Date.now() - startTime;
                    const responseText = await response.text();
                    
                    // è§£ætraceå“åº”
                    const traceData = parseTraceResponse(responseText);
                    
                    if (traceData && traceData.ip && traceData.colo) {
                        // åˆ¤æ–­IPç±»å‹
                        const responseIP = traceData.ip;
                        let ipType = 'official'; // é»˜è®¤å®˜æ–¹IP
                        
                        // æ£€æŸ¥æ˜¯å¦æ˜¯IPv6ï¼ˆåŒ…å«å†’å·ï¼‰æˆ–è€…IPç›¸ç­‰
                        if (responseIP.includes(':') || responseIP === ip) {
                            ipType = 'proxy'; // åä»£IP
                        }
                        // å¦‚æœresponseIPä¸ipä¸ç›¸ç­‰ä¸”ä¸æ˜¯IPv6ï¼Œåˆ™æ˜¯å®˜æ–¹IP
                        
                        return {
                            ip: ip,
                            port: port,
                            latency: latency,
                            colo: traceData.colo,
                            type: ipType,
                            responseIP: responseIP
                        };
                    }
                }
                
                return null;
                
            } catch (error) {
                const latency = Date.now() - startTime;
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯çœŸæ­£çš„è¶…æ—¶ï¼ˆæ¥è¿‘è®¾å®šçš„timeoutæ—¶é—´ï¼‰
                if (latency >= timeout - 100) {
                    return null;
                }
                
                return null;
            }
        }
        
        // æ–°å¢ï¼šè§£ætraceå“åº”çš„å‡½æ•°
        function parseTraceResponse(responseText) {
            try {
                const lines = responseText.split('\\n');
                const data = {};
                
                for (const line of lines) {
                    const trimmedLine = line.trim();
                    if (trimmedLine && trimmedLine.includes('=')) {
                        const [key, value] = trimmedLine.split('=', 2);
                        data[key] = value;
                    }
                }
                
                return data;
            } catch (error) {
                console.error('è§£ætraceå“åº”å¤±è´¥:', error);
                return null;
            }
        }
        
        async function testIPsWithConcurrency(ips, port, maxConcurrency = 32) {
            const results = [];
            const totalIPs = ips.length;
            let completedTests = 0;
            
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');
            
            // åˆ›å»ºå·¥ä½œé˜Ÿåˆ—
            let index = 0;
            
            async function worker() {
                while (index < ips.length) {
                    const currentIndex = index++;
                    const ip = ips[currentIndex];
                    
                    const result = await testIP(ip, port);
                    if (result) {
                        results.push(result);
                    }
                    
                    completedTests++;
                    
                    // æ›´æ–°è¿›åº¦
                    const progress = (completedTests / totalIPs) * 100;
                    progressBar.style.width = progress + '%';
                    progressText.textContent = \`\${completedTests}/\${totalIPs} (\${progress.toFixed(1)}%) - æœ‰æ•ˆIP: \${results.length}\`;
                }
            }
            
            // åˆ›å»ºå·¥ä½œçº¿ç¨‹
            const workers = Array(Math.min(maxConcurrency, ips.length))
                .fill()
                .map(() => worker());
            
            await Promise.all(workers);
            
            return results;
        }
        
        async function startTest() {
            const testBtn = document.getElementById('test-btn');
            const portSelect = document.getElementById('port-select');
            const ipSourceSelect = document.getElementById('ip-source-select');
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');
            const ipList = document.getElementById('ip-list');
            const resultCount = document.getElementById('result-count');
            const ipCount = document.getElementById('ip-count');
            const ipDisplayInfo = document.getElementById('ip-display-info');
            const showMoreSection = document.getElementById('show-more-section');
            
            const selectedPort = portSelect.value;
            const selectedIPSource = ipSourceSelect.value;
            
            // ä¿å­˜å½“å‰é€‰æ‹©åˆ°æœ¬åœ°å­˜å‚¨
            localStorage.setItem(StorageKeys.PORT, selectedPort);
            localStorage.setItem(StorageKeys.IP_SOURCE, selectedIPSource);
            
            testBtn.disabled = true;
            testBtn.textContent = 'åŠ è½½IPåˆ—è¡¨...';
            portSelect.disabled = true;
            ipSourceSelect.disabled = true;
            testResults = [];
            displayedResults = []; // é‡ç½®æ˜¾ç¤ºç»“æœ
            showingAll = false; // é‡ç½®æ˜¾ç¤ºçŠ¶æ€
            currentDisplayType = 'loading'; // è®¾ç½®å½“å‰æ˜¾ç¤ºç±»å‹
            ipList.innerHTML = '<div class="ip-item">æ­£åœ¨åŠ è½½IPåˆ—è¡¨ï¼Œè¯·ç¨å€™...</div>';
            ipDisplayInfo.textContent = '';
            showMoreSection.style.display = 'none';
            updateButtonStates(); // æ›´æ–°æŒ‰é’®çŠ¶æ€
            
            // é‡ç½®è¿›åº¦æ¡
            progressBar.style.width = '0%';
            
            // æ ¹æ®IPåº“ç±»å‹æ˜¾ç¤ºå¯¹åº”çš„åŠ è½½ä¿¡æ¯
            let ipSourceName = '';
            switch(selectedIPSource) {
                case 'official':
                    ipSourceName = 'CFå®˜æ–¹';
                    break;
                case 'cm':
                    ipSourceName = 'CMæ•´ç†';
                    break;
                case 'as13335':
                    ipSourceName = 'CFå…¨æ®µ';
                    break;
                case 'as209242':
                    ipSourceName = 'CFéå®˜æ–¹';
                    break;
                case 'as24429':
                    ipSourceName = 'Alibaba';
                    break;
                case 'as199524':
                    ipSourceName = 'G-Core';
                    break;
                case 'proxyip':
                    ipSourceName = 'åä»£IP';
                    break;
                default:
                    ipSourceName = 'æœªçŸ¥';
            }
            
            progressText.textContent = 'æ­£åœ¨åŠ è½½ ' + ipSourceName + ' IPåˆ—è¡¨...';
            
            // åŠ è½½IPåˆ—è¡¨
            originalIPs = await loadIPs(selectedIPSource, selectedPort);

            if (originalIPs.length === 0) {
                ipList.innerHTML = '<div class="ip-item">åŠ è½½IPåˆ—è¡¨å¤±è´¥ï¼Œè¯·é‡è¯•</div>';
                ipCount.textContent = '0 ä¸ª';
                testBtn.disabled = false;
                testBtn.textContent = 'å¼€å§‹å»¶è¿Ÿæµ‹è¯•';
                portSelect.disabled = false;
                ipSourceSelect.disabled = false;
                progressText.textContent = 'åŠ è½½å¤±è´¥';
                return;
            }
            
            // æ›´æ–°IPæ•°é‡æ˜¾ç¤º
            ipCount.textContent = originalIPs.length + ' ä¸ª';
            
            // æ˜¾ç¤ºåŠ è½½çš„IPåˆ—è¡¨ï¼ˆé»˜è®¤æ˜¾ç¤ºå‰16ä¸ªï¼‰
            displayLoadedIPs();
            
            // å¼€å§‹æµ‹è¯•
            testBtn.textContent = 'æµ‹è¯•ä¸­...';
            progressText.textContent = 'å¼€å§‹æµ‹è¯•ç«¯å£ ' + selectedPort + '...';
            currentDisplayType = 'testing'; // åˆ‡æ¢åˆ°æµ‹è¯•çŠ¶æ€
            
            // åœ¨æµ‹è¯•å¼€å§‹æ—¶éšè—æ˜¾ç¤ºæ›´å¤šæŒ‰é’®
            showMoreSection.style.display = 'none';
            
            // ä½¿ç”¨æ›´é«˜çš„å¹¶å‘æ•°ï¼ˆä»16å¢åŠ åˆ°32ï¼‰æ¥åŠ å¿«æµ‹è¯•é€Ÿåº¦
            const results = await testIPsWithConcurrency(originalIPs, selectedPort, 32);
            
            // æŒ‰å»¶è¿Ÿæ’åº
            testResults = results.sort((a, b) => a.latency - b.latency);
            
            // æ˜¾ç¤ºç»“æœ
            currentDisplayType = 'results'; // åˆ‡æ¢åˆ°ç»“æœæ˜¾ç¤ºçŠ¶æ€
            showingAll = false; // é‡ç½®æ˜¾ç¤ºçŠ¶æ€
            displayResults();
            
            // åˆ›å»ºåœ°åŒºç­›é€‰å™¨
            createRegionFilter();
            
            testBtn.disabled = false;
            testBtn.textContent = 'é‡æ–°æµ‹è¯•';
            portSelect.disabled = false;
            ipSourceSelect.disabled = false;
            progressText.textContent = 'å®Œæˆ - æœ‰æ•ˆIP: ' + testResults.length + '/' + originalIPs.length + ' (ç«¯å£: ' + selectedPort + ', IPåº“: ' + ipSourceName + ')';
        }
        
        // æ–°å¢ï¼šåŠ è½½IPåˆ—è¡¨çš„å‡½æ•°
        async function loadIPs(ipSource, port) {
            try {
                const response = await fetch(\`?loadIPs=\${ipSource}&port=\${port}\`, {
                    method: 'GET'
                });
                
                if (!response.ok) {
                    throw new Error('Failed to load IPs');
                }
                
                const data = await response.json();
                return data.ips || [];
            } catch (error) {
                console.error('åŠ è½½IPåˆ—è¡¨å¤±è´¥:', error);
                return [];
            }
        }
        
        function displayResults() {
            const ipList = document.getElementById('ip-list');
            const resultCount = document.getElementById('result-count');
            const showMoreSection = document.getElementById('show-more-section');
            const showMoreBtn = document.getElementById('show-more-btn');
            const ipDisplayInfo = document.getElementById('ip-display-info');
            
            if (testResults.length === 0) {
                ipList.innerHTML = '<div class="ip-item">æœªæ‰¾åˆ°æœ‰æ•ˆçš„IP</div>';
                resultCount.textContent = '';
                ipDisplayInfo.textContent = '';
                showMoreSection.style.display = 'none';
                displayedResults = [];
                updateButtonStates();
                return;
            }
            
            // ç¡®å®šæ˜¾ç¤ºæ•°é‡
            const maxDisplayCount = showingAll ? testResults.length : Math.min(testResults.length, 16);
            displayedResults = testResults.slice(0, maxDisplayCount);
            
            // æ›´æ–°ç»“æœè®¡æ•°æ˜¾ç¤º
            if (testResults.length <= 16) {
                resultCount.textContent = '(å…±æµ‹è¯•å‡º ' + testResults.length + ' ä¸ªæœ‰æ•ˆIP)';
                ipDisplayInfo.textContent = 'æ˜¾ç¤ºå…¨éƒ¨ ' + testResults.length + ' ä¸ªæµ‹è¯•ç»“æœ';
                showMoreSection.style.display = 'none';
            } else {
                resultCount.textContent = '(å…±æµ‹è¯•å‡º ' + testResults.length + ' ä¸ªæœ‰æ•ˆIP)';
                ipDisplayInfo.textContent = 'æ˜¾ç¤ºå‰ ' + maxDisplayCount + ' ä¸ªæµ‹è¯•ç»“æœï¼Œå…± ' + testResults.length + ' ä¸ªæœ‰æ•ˆIP';
                showMoreSection.style.display = 'block';
                showMoreBtn.textContent = showingAll ? 'æ˜¾ç¤ºæ›´å°‘' : 'æ˜¾ç¤ºæ›´å¤š';
                showMoreBtn.disabled = false; // ç¡®ä¿åœ¨ç»“æœæ˜¾ç¤ºæ—¶å¯ç”¨æŒ‰é’®
            }
            
            const resultsHTML = displayedResults.map(result => {
                let className = 'good-latency';
                if (result.latency > 200) className = 'bad-latency';
                else if (result.latency > 100) className = 'medium-latency';
                
                return '<div class="ip-item ' + className + '">' + result.display + '</div>';
            }).join('');
            
            ipList.innerHTML = resultsHTML;
            updateButtonStates();
        }
        
        // æ–°å¢ï¼šåˆ›å»ºåœ°åŒºç­›é€‰å™¨
        function createRegionFilter() {
            // è·å–æ‰€æœ‰å”¯ä¸€çš„åœ°åŒºä»£ç ï¼ˆä½¿ç”¨cca2ä»£ç ï¼‰
            const uniqueRegions = [...new Set(testResults.map(result => result.locationCode))];
            uniqueRegions.sort(); // æŒ‰å­—æ¯é¡ºåºæ’åº
            
            const filterContainer = document.getElementById('region-filter');
            if (!filterContainer) return;
            
            if (uniqueRegions.length === 0) {
                filterContainer.style.display = 'none';
                return;
            }
            
            // åˆ›å»ºç­›é€‰æŒ‰é’®
            let filterHTML = '<h3>åœ°åŒºç­›é€‰ï¼š</h3><div class="region-buttons">';
            filterHTML += '<button class="region-btn active" data-region="all">å…¨éƒ¨ (' + testResults.length + ')</button>';
            
            uniqueRegions.forEach(region => {
                const count = testResults.filter(r => r.locationCode === region).length;
                filterHTML += '<button class="region-btn" data-region="' + region + '">' + region + ' (' + count + ')</button>';
            });
            
            filterHTML += '</div>';
            filterContainer.innerHTML = filterHTML;
            filterContainer.style.display = 'block';
            
            // æ·»åŠ ç‚¹å‡»äº‹ä»¶
            document.querySelectorAll('.region-btn').forEach(button => {
                button.addEventListener('click', function() {
                    // æ›´æ–°æ´»åŠ¨æŒ‰é’®
                    document.querySelectorAll('.region-btn').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    this.classList.add('active');
                    
                    // ç­›é€‰ç»“æœ
                    const selectedRegion = this.getAttribute('data-region');
                    if (selectedRegion === 'all') {
                        displayedResults = [...testResults];
                    } else {
                        displayedResults = testResults.filter(result => result.locationCode === selectedRegion);
                    }
                    
                    // é‡ç½®æ˜¾ç¤ºçŠ¶æ€
                    showingAll = false;
                    displayFilteredResults();
                });
            });
        }
        
        // æ–°å¢ï¼šæ˜¾ç¤ºç­›é€‰åçš„ç»“æœ
        function displayFilteredResults() {
            const ipList = document.getElementById('ip-list');
            const resultCount = document.getElementById('result-count');
            const showMoreSection = document.getElementById('show-more-section');
            const showMoreBtn = document.getElementById('show-more-btn');
            const ipDisplayInfo = document.getElementById('ip-display-info');
            
            if (displayedResults.length === 0) {
                ipList.innerHTML = '<div class="ip-item">æœªæ‰¾åˆ°æœ‰æ•ˆçš„IP</div>';
                resultCount.textContent = '';
                ipDisplayInfo.textContent = '';
                showMoreSection.style.display = 'none';
                updateButtonStates();
                return;
            }
            
            // ç¡®å®šæ˜¾ç¤ºæ•°é‡
            const maxDisplayCount = showingAll ? displayedResults.length : Math.min(displayedResults.length, 16);
            const currentResults = displayedResults.slice(0, maxDisplayCount);
            
            // æ›´æ–°ç»“æœè®¡æ•°æ˜¾ç¤º
            const totalCount = testResults.length;
            const filteredCount = displayedResults.length;
            
            if (filteredCount <= 16) {
                resultCount.textContent = '(å…±æµ‹è¯•å‡º ' + totalCount + ' ä¸ªæœ‰æ•ˆIPï¼Œç­›é€‰å‡º ' + filteredCount + ' ä¸ª)';
                ipDisplayInfo.textContent = 'æ˜¾ç¤ºå…¨éƒ¨ ' + filteredCount + ' ä¸ªç­›é€‰ç»“æœ';
                showMoreSection.style.display = 'none';
            } else {
                resultCount.textContent = '(å…±æµ‹è¯•å‡º ' + totalCount + ' ä¸ªæœ‰æ•ˆIPï¼Œç­›é€‰å‡º ' + filteredCount + ' ä¸ª)';
                ipDisplayInfo.textContent = 'æ˜¾ç¤ºå‰ ' + maxDisplayCount + ' ä¸ªç­›é€‰ç»“æœï¼Œå…± ' + filteredCount + ' ä¸ª';
                showMoreSection.style.display = 'block';
                showMoreBtn.textContent = showingAll ? 'æ˜¾ç¤ºæ›´å°‘' : 'æ˜¾ç¤ºæ›´å¤š';
                showMoreBtn.disabled = false;
            }
            
            const resultsHTML = currentResults.map(result => {
                let className = 'good-latency';
                if (result.latency > 200) className = 'bad-latency';
                else if (result.latency > 100) className = 'medium-latency';
                
                return '<div class="ip-item ' + className + '">' + result.display + '</div>';
            }).join('');
            
            ipList.innerHTML = resultsHTML;
            updateButtonStates();
        }
    </script>
    
    </body>
    </html>
    `;

    // å¤„ç†åŠ è½½IPçš„è¯·æ±‚
    if (url.searchParams.get('loadIPs')) {
        const ipSource = url.searchParams.get('loadIPs');
        const port = url.searchParams.get('port') || '443';
        const ips = await GetCFIPs(ipSource, port);

        return new Response(JSON.stringify({ ips }), {
            headers: {
                'Content-Type': 'application/json',
            },
        });
    }

    return new Response(html, {
        headers: {
            'Content-Type': 'text/html; charset=UTF-8',
        },
    });
}

/**
 * è·å– Cloudflare è´¦æˆ·ä»Šæ—¥ä½¿ç”¨é‡ç»Ÿè®¡
 * @param {string} accountId - è´¦æˆ·IDï¼ˆå¯é€‰ï¼Œå¦‚æœæ²¡æœ‰ä¼šè‡ªåŠ¨è·å–ï¼‰
 * @param {string} email - Cloudflare è´¦æˆ·é‚®ç®±
 * @param {string} apikey - Cloudflare API å¯†é’¥
 * @param {string} apitoken - Cloudflare API ä»¤ç‰Œ
 * @param {number} all - æ€»é™é¢ï¼Œé»˜è®¤10ä¸‡æ¬¡
 * @returns {Array} [æ€»é™é¢, Pagesè¯·æ±‚æ•°, Workersè¯·æ±‚æ•°, æ€»è¯·æ±‚æ•°]
 */
async function getUsage(accountId, email, apikey, apitoken, all = 100000) {
    /**
     * è·å– Cloudflare è´¦æˆ·ID
     * @param {string} email - è´¦æˆ·é‚®ç®±
     * @param {string} apikey - APIå¯†é’¥
     * @param {number} accountIndex - å–ç¬¬å‡ ä¸ªè´¦æˆ·ï¼Œé»˜è®¤ç¬¬0ä¸ª
     * @returns {string} è´¦æˆ·ID
     */
    async function getAccountId(email, apikey) {
        console.log('æ­£åœ¨è·å–è´¦æˆ·ä¿¡æ¯...');

        const response = await fetch("https://api.cloudflare.com/client/v4/accounts", {
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                "X-AUTH-EMAIL": email,
                "X-AUTH-KEY": apikey,
            }
        });

        if (!response.ok) {
            const errorText = await response.text();
            console.error(`è·å–è´¦æˆ·ä¿¡æ¯å¤±è´¥: ${response.status} ${response.statusText}`, errorText);
            throw new Error(`Cloudflare API è¯·æ±‚å¤±è´¥: ${response.status} ${response.statusText} - ${errorText}`);
        }

        const res = await response.json();
        //console.log(res);

        let accountIndex = 0; // é»˜è®¤å–ç¬¬ä¸€ä¸ªè´¦æˆ·
        let foundMatch = false; // æ ‡è®°æ˜¯å¦æ‰¾åˆ°åŒ¹é…çš„è´¦æˆ·

        // å¦‚æœæœ‰å¤šä¸ªè´¦æˆ·ï¼Œæ™ºèƒ½åŒ¹é…åŒ…å«é‚®ç®±å‰ç¼€çš„è´¦æˆ·
        if (res?.result && res.result.length > 1) {
            console.log(`å‘ç° ${res.result.length} ä¸ªè´¦æˆ·ï¼Œæ­£åœ¨æ™ºèƒ½åŒ¹é…...`);

            // æå–é‚®ç®±å‰ç¼€å¹¶è½¬ä¸ºå°å†™
            const emailPrefix = email.toLowerCase();
            console.log(`é‚®ç®±: ${emailPrefix}`);

            // éå†æ‰€æœ‰è´¦æˆ·ï¼Œå¯»æ‰¾åç§°å¼€å¤´åŒ…å«é‚®ç®±å‰ç¼€çš„è´¦æˆ·
            for (let i = 0; i < res.result.length; i++) {
                const accountName = res.result[i]?.name?.toLowerCase() || '';
                console.log(`æ£€æŸ¥è´¦æˆ· ${i}: ${res.result[i]?.name}`);

                // æ£€æŸ¥è´¦æˆ·åç§°å¼€å¤´æ˜¯å¦åŒ…å«é‚®ç®±å‰ç¼€
                if (accountName.startsWith(emailPrefix)) {
                    accountIndex = i;
                    foundMatch = true;
                    console.log(`âœ… æ‰¾åˆ°åŒ¹é…è´¦æˆ·ï¼Œä½¿ç”¨ç¬¬ ${i} ä¸ªè´¦æˆ·`);
                    break;
                }
            }

            // å¦‚æœéå†å®Œè¿˜æ²¡æ‰¾åˆ°åŒ¹é…çš„ï¼Œä½¿ç”¨é»˜è®¤å€¼0
            if (!foundMatch) {
                console.log('âŒ æœªæ‰¾åˆ°åŒ¹é…çš„è´¦æˆ·ï¼Œä½¿ç”¨é»˜è®¤ç¬¬ 0 ä¸ªè´¦æˆ·');
            }
        } else if (res?.result && res.result.length === 1) {
            console.log('åªæœ‰ä¸€ä¸ªè´¦æˆ·ï¼Œä½¿ç”¨ç¬¬ 0 ä¸ªè´¦æˆ·');
            foundMatch = true;
        }

        const name = res?.result?.[accountIndex]?.name;
        const id = res?.result?.[accountIndex]?.id;

        console.log(`æœ€ç»ˆé€‰æ‹©è´¦æˆ· ${accountIndex} - åç§°: ${name}, ID: ${id}`);

        if (!id) {
            throw new Error("æ‰¾ä¸åˆ°æœ‰æ•ˆçš„è´¦æˆ·IDï¼Œè¯·æ£€æŸ¥APIæƒé™");
        }

        return id;
    }

    try {
        // å¦‚æœæ²¡æœ‰æä¾›è´¦æˆ·IDï¼Œå°±è‡ªåŠ¨è·å–
        if (!accountId) {
            console.log('æœªæä¾›è´¦æˆ·IDï¼Œæ­£åœ¨è‡ªåŠ¨è·å–...');
            accountId = await getAccountId(email, apikey);
        }

        // è®¾ç½®æŸ¥è¯¢æ—¶é—´èŒƒå›´ï¼šä»Šå¤©0ç‚¹åˆ°ç°åœ¨
        const now = new Date();
        const endDate = now.toISOString(); // ç»“æŸæ—¶é—´ï¼šç°åœ¨

        // è®¾ç½®å¼€å§‹æ—¶é—´ä¸ºä»Šå¤©å‡Œæ™¨0ç‚¹
        now.setUTCHours(0, 0, 0, 0);
        const startDate = now.toISOString(); // å¼€å§‹æ—¶é—´ï¼šä»Šå¤©0ç‚¹

        console.log(`æŸ¥è¯¢æ—¶é—´èŒƒå›´: ${startDate} åˆ° ${endDate}`);
        // å‡†å¤‡è¯·æ±‚å¤´
        let headers = {}
        if (apikey) {
            headers = {
                "Content-Type": "application/json",
                "X-AUTH-EMAIL": email,
                "X-AUTH-KEY": apikey,
            };
        }
        if (apitoken) {
            headers = {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${apitoken}`,
            }
        }

        // å‘ Cloudflare GraphQL API å‘é€è¯·æ±‚ï¼Œè·å–ä»Šæ—¥ä½¿ç”¨é‡
        const response = await fetch("https://api.cloudflare.com/client/v4/graphql", {
            method: "POST",
            headers: headers,
            body: JSON.stringify({
                // GraphQL æŸ¥è¯¢è¯­å¥ï¼šè·å– Pages å’Œ Workers çš„è¯·æ±‚æ•°ç»Ÿè®¡
                query: `query getBillingMetrics($accountId: String!, $filter: AccountWorkersInvocationsAdaptiveFilter_InputObject) {
                    viewer {
                        accounts(filter: {accountTag: $accountId}) {
                            pagesFunctionsInvocationsAdaptiveGroups(limit: 1000, filter: $filter) {
                                sum {
                                    requests
                                }
                            }
                            workersInvocationsAdaptive(limit: 10000, filter: $filter) {
                                sum {
                                    requests
                                }
                            }
                        }
                    }
                }`,
                variables: {
                    accountId: accountId,
                    filter: {
                        datetime_geq: startDate, // å¤§äºç­‰äºå¼€å§‹æ—¶é—´
                        datetime_leq: endDate    // å°äºç­‰äºç»“æŸæ—¶é—´
                    },
                },
            }),
        });

        // æ£€æŸ¥APIè¯·æ±‚æ˜¯å¦æˆåŠŸ
        if (!response.ok) {
            const errorText = await response.text();
            console.error(`GraphQLæŸ¥è¯¢å¤±è´¥: ${response.status} ${response.statusText}`, errorText);
            console.log('è¿”å›é»˜è®¤å€¼ï¼šå…¨éƒ¨ä¸º0');
            return [all, 0, 0, 0];
        }

        const res = await response.json();

        // æ£€æŸ¥GraphQLå“åº”æ˜¯å¦æœ‰é”™è¯¯
        if (res.errors && res.errors.length > 0) {
            console.error('GraphQLæŸ¥è¯¢é”™è¯¯:', res.errors[0].message);
            console.log('è¿”å›é»˜è®¤å€¼ï¼šå…¨éƒ¨ä¸º0');
            return [all, 0, 0, 0];
        }

        // ä»å“åº”ä¸­æå–è´¦æˆ·æ•°æ®
        const accounts = res?.data?.viewer?.accounts?.[0];

        if (!accounts) {
            console.warn('æœªæ‰¾åˆ°è´¦æˆ·æ•°æ®');
            return [all, 0, 0, 0];
        }

        // è®¡ç®— Pages è¯·æ±‚æ•°ï¼ˆCloudflare Pages çš„è¯·æ±‚ç»Ÿè®¡ï¼‰
        const pagesArray = accounts?.pagesFunctionsInvocationsAdaptiveGroups || [];
        const pages = pagesArray.reduce((total, item) => {
            return total + (item?.sum?.requests || 0);
        }, 0);

        // è®¡ç®— Workers è¯·æ±‚æ•°ï¼ˆCloudflare Workers çš„è¯·æ±‚ç»Ÿè®¡ï¼‰
        const workersArray = accounts?.workersInvocationsAdaptive || [];
        const workers = workersArray.reduce((total, item) => {
            return total + (item?.sum?.requests || 0);
        }, 0);

        // è®¡ç®—æ€»è¯·æ±‚æ•°
        const total = pages + workers;

        console.log(`ç»Ÿè®¡ç»“æœ - Pages: ${pages}, Workers: ${workers}, æ€»è®¡: ${total}`);

        // è¿”å›æ ¼å¼ï¼š[æ€»é™é¢, Pagesè¯·æ±‚æ•°, Workersè¯·æ±‚æ•°, æ€»è¯·æ±‚æ•°]
        return [all, pages || 0, workers || 0, total || 0];

    } catch (error) {
        console.error('è·å–ä½¿ç”¨é‡æ—¶å‘ç”Ÿé”™è¯¯:', error.message);
        // å‘ç”Ÿé”™è¯¯æ—¶è¿”å›é»˜è®¤å€¼
        return [all, 0, 0, 0];
    }
}

async function nginx() {
    const text = `
	<!DOCTYPE html>
	<html>
	<head>
	<title>Welcome to nginx!</title>
	<style>
		body {
			width: 35em;
			margin: 0 auto;
			font-family: Tahoma, Verdana, Arial, sans-serif;
		}
	</style>
	</head>
	<body>
	<h1>Welcome to nginx!</h1>
	<p>If you see this page, the nginx web server is successfully installed and
	working. Further configuration is required.</p>
	
	<p>For online documentation and support please refer to
	<a href="http://nginx.org/">nginx.org</a>.<br/>
	Commercial support is available at
	<a href="http://nginx.com/">nginx.com</a>.</p>
	
	<p><em>Thank you for using nginx.</em></p>
	</body>
	</html>
	`
    return text;
}
